//std_functions.zh for 2.54
//19-Dec-2016
// Since last .txtfile / docs: Added DistXY(), LeftOf(), RightOf(), Above(), Below(), FlipRef(), ReflectWeapon()
//Fixed and updated AdjacentCombo: It now uses the same DIR_ values as everything else. 
//
// Some utility routines
//

//Wait for n frames
void Waitframes(int n) {
	while(n-- > 0) Waitframe();
}

//Returns a if cond is true, else b. Overloaded.
float Cond(bool cond, float a, float b) {
	if (cond) return a;
	else return b;
}

bool Cond(bool cond, bool a, bool b) {
	if (cond) return a;
	else return b;
}

npc Cond(bool cond, npc a, npc b) {
	if (cond) return a;
	else return b;
}

item Cond(bool cond, item a, item b) {
	if (cond) return a;
	else return b;
}

lweapon Cond(bool cond, lweapon a, lweapon b) {
	if (cond) return a;
	else return b;
}

eweapon Cond(bool cond, eweapon a, eweapon b) {
	if (cond) return a;
	else return b;
}

ffc Cond(bool cond, ffc a, ffc b) {
	if (cond) return a;
	else return b;
}

itemdata Cond(bool cond, itemdata a, itemdata b) {
	if (cond) return a;
	else return b;
}

// Chooses one of the options randomly and fairly.
float Choose(float a, float b) {
	if (Rand(0,1)==0) return a;
	else return b;
}

float Choose(float a, float b, float c) {
	int r = Rand(0,2);
	if (r==0) return a;
	else if (r==1) return b;
	else return c;
}

float Choose(float a, float b, float c, float d) {
	int r = Rand(0,3);
	if (r==0) return a;
	else if (r==1) return b;
	else if (r==2) return c;
	else return d;
}

float Choose(float a, float b, float c, float d, float e) {
	int r = Rand(0,4);
	if (r==0) return a;
	else if (r==1) return b;
	else if (r==2) return c;
	else if (r==3) return d;
	else return e;
}

float Choose(float a, float b, float c, float d, float e, float f) {
	int r = Rand(0,5);
	if (r==0) return a;
	else if (r==1) return b;
	else if (r==2) return c;
	else if (r==3) return d;
	else if (r==4) return e;
	else return f;
}

float Choose(float a, float b, float c, float d, float e, float f, float g) {
	int r = Rand(0,6);
	if (r==0) return a;
	else if (r==1) return b;
	else if (r==2) return c;
	else if (r==3) return d;
	else if (r==4) return e;
	else if (r==5) return f;
	else return g;
}

float Choose(float a, float b, float c, float d, float e, float f, float g, float h) {
	int r = Rand(0,7);
	if (r==0) return a;
	else if (r==1) return b;
	else if (r==2) return c;
	else if (r==3) return d;
	else if (r==4) return e;
	else if (r==5) return f;
	else if (r==6) return g;
	else return h;
}

float Choose(float a, float b, float c, float d, float e, float f, float g, float h, float i) {
	int r = Rand(0,8);
	if (r==0) return a;
	else if (r==1) return b;
	else if (r==2) return c;
	else if (r==3) return d;
	else if (r==4) return e;
	else if (r==5) return f;
	else if (r==6) return g;
	else if (r==7) return h;
	else return i;
}

float Choose(float a, float b, float c, float d, float e, float f, float g, float h, float i,
		float j) {
	int r = Rand(0,9);
	if (r==0) return a;
	else if (r==1) return b;
	else if (r==2) return c;
	else if (r==3) return d;
	else if (r==4) return e;
	else if (r==5) return f;
	else if (r==6) return g;
	else if (r==7) return h;
	else if (r==8) return i;
	else return j;
}

float Choose(float a, float b, float c, float d, float e, float f, float g, float h, float i,
		float j, float k) {
	int r = Rand(0,10);
	if (r==0) return a;
	else if (r==1) return b;
	else if (r==2) return c;
	else if (r==3) return d;
	else if (r==4) return e;
	else if (r==5) return f;
	else if (r==6) return g;
	else if (r==7) return h;
	else if (r==8) return i;
	else if (r==9) return j;
	else return k;
}

float Choose(float a, float b, float c, float d, float e, float f, float g, float h, float i,
		float j, float k, float l) {
	int r = Rand(0,11);
	if (r==0) return a;
	else if (r==1) return b;
	else if (r==2) return c;
	else if (r==3) return d;
	else if (r==4) return e;
	else if (r==5) return f;
	else if (r==6) return g;
	else if (r==7) return h;
	else if (r==8) return i;
	else if (r==9) return j;
	else if (r==10) return k;
	else return l;
}

float Choose(float a, float b, float c, float d, float e, float f, float g, float h, float i,
		float j, float k, float l, float m) {
	int r = Rand(0,12);
	if (r==0) return a;
	else if (r==1) return b;
	else if (r==2) return c;
	else if (r==3) return d;
	else if (r==4) return e;
	else if (r==5) return f;
	else if (r==6) return g;
	else if (r==7) return h;
	else if (r==8) return i;
	else if (r==9) return j;
	else if (r==10) return k;
	else if (r==11) return l;
	else return m;
}

float Choose(float a, float b, float c, float d, float e, float f, float g, float h, float i,
		float j, float k, float l, float m, float n) {
	int r = Rand(0,13);
	if (r==0) return a;
	else if (r==1) return b;
	else if (r==2) return c;
	else if (r==3) return d;
	else if (r==4) return e;
	else if (r==5) return f;
	else if (r==6) return g;
	else if (r==7) return h;
	else if (r==8) return i;
	else if (r==9) return j;
	else if (r==10) return k;
	else if (r==11) return l;
	else if (r==12) return m;
	else return n;
}

float Choose(float a, float b, float c, float d, float e, float f, float g, float h, float i,
		float j, float k, float l, float m, float n, float o) {
	int r = Rand(0,14);
	if (r==0) return a;
	else if (r==1) return b;
	else if (r==2) return c;
	else if (r==3) return d;
	else if (r==4) return e;
	else if (r==5) return f;
	else if (r==6) return g;
	else if (r==7) return h;
	else if (r==8) return i;
	else if (r==9) return j;
	else if (r==10) return k;
	else if (r==11) return l;
	else if (r==12) return m;
	else if (r==13) return n;
	else return o;
}

float Choose(float a, float b, float c, float d, float e, float f, float g, float h, float i,
		float j, float k, float l, float m, float n, float o, float p) {
	int r = Rand(0,15);
	if (r==0) return a;
	else if (r==1) return b;
	else if (r==2) return c;
	else if (r==3) return d;
	else if (r==4) return e;
	else if (r==5) return f;
	else if (r==6) return g;
	else if (r==7) return h;
	else if (r==8) return i;
	else if (r==9) return j;
	else if (r==10) return k;
	else if (r==11) return l;
	else if (r==12) return m;
	else if (r==13) return n;
	else if (r==14) return o;
	else return p;
}



//Returns the logarithm of x to the given base
float LogToBase(float x, float base){
	return Ln(x)/Ln(base);
}

//Truncates x to an integer
int Floor(float x) {
	if(x < 0)
		return (x-.9999)<<0;
	return x<<0;
}

//Raises x to the nearest integer
int Ceiling(float x) {
	if(x < 0)
		return x<<0;
	return (x+.9999)<<0;
}

//Rounds x to the nearest integer
float Round(float x) {
	if(x < 0)
		return (x-.5)<<0;
	return (x+.5)<<0;
}

//Returns true if the integer is odd (or even in IsEven)
bool IsOdd(int x) {
	return ((x & 1) == 1);
}

bool IsEven(int x) {
	return ((x & 1) == 0);
}

//Clamps x to the range of low, high.
int Clamp(int x, int low, int high) {
	if(x<low) x=low;
	else if(x>high) x=high;
	return x;
}

//same as Clamp, but with reversed values.
int VBound(int x, int high, int low) {
	if(x<low) x=low;
	else if(x>high) x=high;
	return x;
}

int vbound(int a, int b, int c) { return VBound(a,b,c);}

//Returns the Quotient only of x divided by y
int Div(float x, float y) {
	return (x/y)<<0;
}

//Returns a random integer in the bounds of min and max
//Permits reversed args. 
int Rand(int min, int max) {
    if ( max < min ) return max+(Rand((1+min)-max));
	else return min+(Rand((1+max)-min));
}

//Returns a random floating point number up to n
float Randf(float n) {
	return (Rand(0x7fff)/0x7fff)*n;
}

//Returns a random floating point number between min and max
//Updated to allow reversed args
float Randf(float n1, float n2) {
	if ( n2 < n1 ) return n2 + (Rand(0x7fff)/(0x7fff))*(n1-n2);
    else return n1 + (Rand(0x7fff)/(0x7fff))*(n2-n1);
}

//Converts 'd' in degrees to radians
float DegtoRad(float d) {
	return d*0.0174;
}

//Converts 'r' in radians to degrees
float RadtoDeg(float r) {
	return r*57.2958;
}

//Returns the sign of n
int Sign(int n) {
	if (n > 0) return 1;
	else if (n < 0) return -1;
	else return 0;
}

//Finds the location of a combo, given its (x,y) coordinates on the screen
int ComboAt(int x, int y) {
	x = VBound(x,255,0);
	y = VBound(y,175,0);
	return (y & 240)+(x>>4);
}

//Snaps 'x' to the combo grid
//Equivalent to calling ComboX(ComboAt(x,foo));
int GridX(int x) {
	return (x >> 4) << 4;
}

//Snaps 'y' to the combo grid
//Equivalent to calling ComboY(ComboAt(foo,y));
int GridY(int y) {
	return (y >> 4) << 4;
}


//Returns the correct offset to be at the front of a sprite facing in the direction 'dir'
int AtFrontX(int dir) {
	int x = 0;
	if(dir == DIR_UP || dir == DIR_DOWN) x = 8;
	else if(dir == DIR_RIGHT) x = 16;
	return x;
}

int AtFrontY(int dir) {
	int y = 0;
	if(dir == DIR_DOWN) y = 16;
	else if(dir == DIR_LEFT || dir == DIR_RIGHT) y = 8;
	return y;
}

//Returns the correct offset to be 'dist' pixels away from the front of a sprite facing in the direction 'dir'
int InFrontX(int dir, int dist) {
	int x = 0;
	if(dir == DIR_LEFT) x = -16+dist;
	else if(dir == DIR_RIGHT) x = 16-dist;
	return x;
}

int InFrontY(int dir, int dist){
	int y = 0;
	if(dir == DIR_UP) y = -16+dist;
	else if(dir == DIR_DOWN) y = 16-dist;
	return y;
}

// Get the X and Y coordinates at the center of a sprite. 
//Overloaded to accept all types. 
int CenterX(ffc anFFC) { return anFFC->X+8*anFFC->TileWidth; }
int CenterY(ffc anFFC) { return anFFC->Y+8*anFFC->TileHeight; }

int CenterX(npc anNPC) { 
	if ( STD_CENTERXY_USES_HITBOXES ) return anNPC->Y+anNPC->HitWidth/2 + anNPC->HitXOffset;
	else return anNPC->X+8*anNPC->TileWidth; 
}

int CenterY(npc anNPC) { 
	if ( STD_CENTERXY_USES_HITBOXES ) return anNPC->Y+anNPC->HitHeight/2 + anNPC->HitYOffset;
	else return anNPC->Y+8*anNPC->TileHeight; 
}

int CenterX(item anItem) { 
	if ( STD_CENTERXY_USES_HITBOXES ) return anItem->Y+anItem->HitWidth/2 + anItem->HitXOffset;
	else return anItem->X+8*anItem->TileWidth; 
}

int CenterY(item anItem) { 
	if ( STD_CENTERXY_USES_HITBOXES ) return anItem->Y+anItem->HitHeight/2 + anItem->HitYOffset;
	else return anItem->Y+8*anItem->TileHeight; 
}


int CenterX(eweapon anEWeapon) { 
	if ( STD_CENTERXY_USES_HITBOXES ) return anEWeapon->Y+anEWeapon->HitWidth/2 + anEWeapon->HitXOffset;
	else return anEWeapon->X+8*anEWeapon->TileWidth; 
}

int CenterY(eweapon anEWeapon) {
	if ( STD_CENTERXY_USES_HITBOXES ) return anEWeapon->Y+anEWeapon->HitHeight/2 + anEWeapon->HitYOffset;
	else return anEWeapon->Y+8*anEWeapon->TileHeight; 
}

int CenterX(lweapon anLWeapon) { 
	if ( STD_CENTERXY_USES_HITBOXES ) return anLWeapon->Y+anLWeapon->HitWidth/2 + anLWeapon->HitXOffset;
	else return anLWeapon->X+8*anLWeapon->TileWidth; 
}


int CenterY(lweapon anLWeapon) { 
	if ( STD_CENTERXY_USES_HITBOXES ) return anLWeapon->Y+anLWeapon->HitHeight/2 + anLWeapon->HitYOffset;
	else return anLWeapon->Y+8*anLWeapon->TileHeight; 
}

//Returns the X and Y coordinates of the centre of Link. 
int CenterLinkX() { return Link->X+8; }
int CenterLinkY() { return Link->Y+8; }

//Return the coordinates of a combo on the screen
int ComboX(int loc) {
	return loc%16*16;
}

int ComboY(int loc) {
    return loc&0xF0;
}

//Returns true if the combo at '(x, y)' has either an inherent or place flag of type 'flag'
bool ComboFI(int x, int y, int flag){
	int loc = ComboAt(x,y);
	return Screen->ComboF[loc] == flag || Screen->ComboI[loc] == flag;
}

//Returns true if the combo at 'loc' has either an inherent or place flag of type 'flag'
bool ComboFI(int loc, int flag){
	return Screen->ComboF[loc] == flag || Screen->ComboI[loc] == flag;
}

//Sets bit 'bit' of Screen->D[] register 'd' to 'state'
void SetScreenDBit(int dmap, int screen, int d, int bit, bool state){
	int curstate = Game->GetDMapScreenD(dmap, screen, d);
	if(state)	Game->SetDMapScreenD(dmap, screen, d, curstate |  (1 << bit));
	else 		Game->SetDMapScreenD(dmap, screen, d, curstate & ~(1 << bit));
}

void SetScreenDBit(int screen, int d, int bit, bool state){
	int curstate = Game->GetScreenD(screen, d);
	if(state)	Game->SetScreenD(screen, d, curstate |  (1 << bit));
	else 		Game->SetScreenD(screen, d, curstate & ~(1 << bit));
}

void SetScreenDBit(int d, int bit, bool state){
    if(state)	Screen->D[d] |= (1 << bit);
    else		Screen->D[d] &= ~(1 << bit);
}

//Returns the state of bit 'bit' of Screen->D[] register 'd'
bool GetScreenDBit(int dmap, int screen, int d, int bit){
	return ( Game->GetDMapScreenD(dmap, screen, d) & (1 << bit) ) != 0;
}

bool GetScreenDBit(int screen, int d, int bit){
	return ( Game->GetScreenD(screen, d) & (1 << bit) ) != 0;
}

bool GetScreenDBit(int d, int bit){
    return (Screen->D[d] & (1 << bit)) != 0;
}

//A shorthand way to get a combo on the current layer.
//Layer 0 is the screen itself.
int GetLayerComboD(int layer, int pos) {
	if (layer==0) return Screen->ComboD[pos];
	else return Game->GetComboData(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos);
}

//A shorthand way to set a combo on the current layer.
//Layer 0 is the screen itself.
void SetLayerComboD(int layer, int pos, int combo) {
	if (layer == 0) Screen->ComboD[pos] = combo;
	else Game->SetComboData(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos, combo);
}

//A shorthand way to get a combo flag on the current layer.
//Layer 0 is the screen itself.
int GetLayerComboF(int layer, int pos) {
	if (layer==0) return Screen->ComboF[pos];
	else return Game->GetComboFlag(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos);
}

//A shorthand way to set a combo flag on the current layer.
//Layer 0 is the screen itself.
void SetLayerComboF(int layer, int pos, int flag) {
	if (layer == 0) Screen->ComboF[pos] = flag;
	else Game->SetComboFlag(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos, flag);
}

//A shorthand way to get a combo type on the current layer.
//Layer 0 is the screen itself.
int GetLayerComboT(int layer, int pos) {
	if (layer==0) return Screen->ComboT[pos];
	else return Game->GetComboType(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos);
}

//A shorthand way to set a combo type on the current layer.
//Layer 0 is the screen itself.
void SetLayerComboT(int layer, int pos, int type) {
	if (layer == 0) Screen->ComboT[pos] = type;
	else Game->SetComboType(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos, type);
}

//A shorthand way to get a combo's solidity on the current layer.
//Layer 0 is the screen itself.
int GetLayerComboS(int layer, int pos) {
	if (layer==0) return Screen->ComboS[pos];
	else return Game->GetComboSolid(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos);
}

//A shorthand way to set a combo's solidity on the current layer.
//Layer 0 is the screen itself.
void SetLayerComboS(int layer, int pos, int solidity) {
	if (layer == 0) Screen->ComboS[pos] = solidity;
	if ( MIN_CONSTANT > -214747.9999 ) { //Not compile don 2.50.3
		if ( layer == 1 ) 
		Game->SetComboSolid(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos, solidity);
		else if ( layer > 1 ) {
			int str[]="Setting solidity on layers higher than 1 causes this version of ZC to crash.";
			TraceS(str);
		}
	}
	else Game->SetComboSolid(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos, solidity);
}

//A shorthand way to get a combo inherent flag on the current layer.
//Layer 0 is the screen itself.
int GetLayerComboI(int layer, int pos) {
	if (layer==0) return Screen->ComboI[pos];
	else return Game->GetComboInherentFlag(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos);
}

//A shorthand way to set a combo inherent flag on the current layer.
//Layer 0 is the screen itself.
void SetLayerComboI(int layer, int pos, int flag) {
	if (layer == 0) Screen->ComboI[pos] = flag;
	else Game->SetComboInherentFlag(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos, flag);
}

//A shorthand way to get a combo CSet on the current layer.
//Layer 0 is the screen itself.
int GetLayerComboC(int layer, int pos) {
	if (layer==0) return Screen->ComboC[pos];
	else return Game->GetComboCSet(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos);
}

//A shorthand way to set a combo CSet on the current layer.
//Layer 0 is the screen itself.
void SetLayerComboC(int layer, int pos, int cset) {
	if (layer == 0) Screen->ComboC[pos] = cset;
	else Game->SetComboCSet(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos, cset);
}


//Copies the combos and csets from one screen to another.
//Only copies layer 0!
void ScreenCopy(int destmap, int destscr, int srcmap, int srcscr) {
	for (int i = 0; i < 176; i++) {
		Game->SetComboData(destmap,destscr, i, Game->GetComboData(srcmap,srcscr,i));
		Game->SetComboCSet(destmap,destscr, i, Game->GetComboCSet(srcmap,srcscr,i));
	}
}

//Swaps a row of tiles of length 'length' between positions 'first' and 'second'
void SwapTileRow(int first, int second, int length){
	for(int i=0;i<length;i++) SwapTile(first+i,second+i);
}

//Copies a row of tiles of length 'length' from 'source' onto 'dest'
void CopyTileRow(int source, int dest, int length){
	for(int i=0;i<length;i++) CopyTile(source+i,dest+i);
}

//Clears a row of tiles of length 'length' starting from tile 'ref'
void ClearTileRow(int ref, int length){
	for(int i=0;i<length;i++) ClearTile(ref+i);
}

//Swaps a block of tiles defined by diagonal corners 'first' and 'last'
//with the block starting with top left tile 'second'
void SwapTileBlock(int first, int last, int second){
	if(last < first){
		int swap = first;
		first = last;
		last = swap;
	}
	int w = last%20-first%20;
	if(w < 0){
		first -= w;
		last += w;
		w = -w;
	}
	for(int i=0;i<=last-first;i++) if(i%20 <= w) SwapTile(first+i,second+i);
}

//Copies a block of tiles defined by diagonal corners 'sourcefirst' and 'sourcelast'
//onto the block starting with top left tile 'destfirst'
void CopyTileBlock(int sourcefirst, int sourcelast, int destfirst){
	if(sourcelast < sourcefirst){
		int swap = sourcefirst;
		sourcefirst = sourcelast;
		sourcelast = swap;
	}
	int w = sourcelast%20-sourcefirst%20;
	if(w < 0){
		sourcefirst -= w;
		sourcelast += w;
		w = -w;
	}
	for(int i=0;i<=sourcelast-sourcefirst;i++) if(i%20 <= w) CopyTile(sourcefirst+i,destfirst+i);
}

//Clears a block of tiles defined by diagonal corners 'reffirst' and 'reflast'
void ClearTileBlock(int reffirst, int reflast){
	if(reflast < reffirst){
		int swap = reffirst;
		reffirst = reflast;
		reflast = swap;
	}
	int w = reflast%20-reffirst%20;
	if(w < 0){
		reffirst -= w;
		reflast += w;
		w = -w;
	}
	for(int i=0;i<=reflast-reffirst;i++) if(i%20 <= w) ClearTile(reffirst+i);
}


//Overload to Screen->DrawString which includes a position to start drawing from in the string
//Does not check for overflow
void DrawString(int layer, int x, int y, int font, int color, int background_color, int format, int opacity,
				int string, int start){
	int buffer[256];
	for(int i=start;string[i]!=0;i++) buffer[i-start] = string[i];
	Screen->DrawString(layer,x,y,font,color,background_color,format,opacity,buffer);
}

//Overload to Screen->DrawString which includes a start and end position to draw the string
//Does not check for overflow
void DrawString(int layer, int x, int y, int font, int color, int background_color, int format, int opacity,
				int string, int start, int end){
	int buffer[256];
	for(int i=start;i<end;i++) buffer[i-start] = string[i];
	Screen->DrawString(layer,x,y,font,color,background_color,format,opacity,buffer);
}


// A very simple layer 0 tile drawing routine.
void DrawTileSimple(int x, int y, int tile, int color) {
	Screen->FastTile(0, x, y, tile, color, 128);
}


//Returns the distance between two sets of coordinates using Pythagoras' Theorem
float Distance(int x1, int y1, int x2, int y2) {
	int x = (x1-x2);
	int y = (y1-y2);
	if ( STD_FORCE_OLD_DISTANCE ) return Sqrt(x*x+y*y);
	else {
		if ( ( x * y ) < 0 ) { 
			
			if ( STD_DISTANCE_USE_SAFESQRT ) return SafeSqrt(x*x+y*y);
			else {
				
				//...or reduce factor by MAX_INT, Sqrt(factor) and add 464?
				//...which way does it roll over?
				//factor = ; 
				int factor =  214747.9999 + (x*y);
				if ( factor > 0 ) return Sqrt(factor) + 464;
				else if ( factor == 0 ) return 464;
				else return Sqrt(214747.9999);
				//else return -1;
				//return Sqrt(( x*y ) * -1) + 464;
			}
		}
	}
		//
}

//Returns the distance between two sets of coordinates using Pythagoras' Theorem
//Allows scaling for large distance determinations.
//Argument 'scale' represents a ratio of 1:scale.
//Argument 'scale' is most precise when using powers of 10 (i.e. 1, 10, 100, 1000, 10000).
//If arg 'scale' is set to 0, it defaults to '1'. 
//Returns -1 on error. 
float Distance(int x1, int y1, int x2, int y2, int scale) {
	if ( scale == 0 ) scale = 1; 
	float x = (x1-x2) / scale;
	float y = (y1-y2) / scale;
	float factor = (x*x)+(y*y);
	if ( factor < 0 ) return -1;
	else return Sqrt(factor) * scale;
}




//Returns the distance between two sets of coordinates using Pythagoras' Theorem
float SafeDistance(int x1, int y1, int x2, int y2) {
	int x; 
	int y;
	if ( x1 > x2 ) x = x1-x2;
	else x = x2 - x1;
	if ( y1 > y2 ) y = y1-y2;
	else y = y2 - y1;
	return Sqrt(x*x+y*y);
}

//Returns the distance between two sets of coordinates using Pythagoras' Theorem
//Arg specify_negative_value is used to specify a value to return is a negative number is parsed to
//determine a square root. 
//float Distance(int x1, int y1, int x2, int y2, int specify_negative_value) {
//	int x = (x1-x2);
//	int y = (y1-y2);
//	return SafeSqrt(x*x+y*y, specify_negative_value);
//}


//Returns the direction of the vector from point 1 to point 2, in degrees from -180 to 180. (0 = right)
float Angle(int x1, int y1, int x2, int y2) {
	return ArcTan(x2-x1, y2-y1)*57.2958;
}

//The above, but in radians.
float RadianAngle(int x1, int y1, int x2, int y2) {
	return ArcTan(x2-x1, y2-y1);
}

//Kills inputs from A, B, L, R, Start, Map, and Ex buttons. 
void NoInput(){ 
	Link->InputA = false;
	Link->InputB = false;
	Link->InputL = false;
	Link->InputR = false;
	Link->InputEx1 = false;
	Link->InputEx2 = false;
	Link->InputEx3 = false;
	Link->InputEx4 = false;
	Link->InputStart = false;
	Link->InputMap = false;
}

//Kills presses from A, B, L, R, Start, Map, and Ex buttons. 
void NoPress(){ 
	Link->PressA = false;
	Link->PressB = false;
	Link->PressL = false;
	Link->PressR = false;
	Link->PressEx1 = false;
	Link->PressEx2 = false;
	Link->PressEx3 = false;
	Link->PressEx4 = false;
	Link->PressStart = false;
	Link->PressMap = false;
}

//Kills inputs from A, B, L, R, Start, Map, and Ex buttons. 
void NoInput(bool stick){ 
	Link->InputA = false;
	Link->InputB = false;
	Link->InputL = false;
	Link->InputR = false;
	Link->InputEx1 = false;
	Link->InputEx2 = false;
	Link->InputEx3 = false;
	Link->InputEx4 = false;
	Link->InputStart = false;
	Link->InputMap = false;
	if ( stick ) {
		Link->InputAxisUp = false; 
		Link->InputAxisDown = false; 
		Link->InputAxisLeft = false; 
		Link->InputAxisRight = false; 
	}
}

//Kills presses from A, B, L, R, Start, Map, and Ex buttons. 
void NoPress(bool stick){ 
	Link->PressA = false;
	Link->PressB = false;
	Link->PressL = false;
	Link->PressR = false;
	Link->PressEx1 = false;
	Link->PressEx2 = false;
	Link->PressEx3 = false;
	Link->PressEx4 = false;
	Link->PressStart = false;
	Link->PressMap = false;
	if ( stick ) {
		Link->PressAxisUp = false; 
		Link->PressAxisDown = false; 
		Link->PressAxisLeft = false; 
		Link->PressAxisRight = false; 
	}
}

	
	
// Returns the X component of a vector with a degree angle.
// A length of 3 and angle of 0 returns 3.
// A length of 3 and angle of 45 returns approx. 1.57.
// A length of 3 and angle of 90 returns 0.
float VectorX(int len, float angle) {
	return Cos(angle)*len;
}

// Returns the Y component of a vector with a degree angle.
// A length of 3 and angle of 0 returns 0.
// A length of 3 and angle of 45 returns approx. 1.57.
// A length of 3 and angle of 90 returns 3.
float VectorY(int len, float angle) {
	return Sin(angle)*len;
}

//rotates X about a center point by an amount of degrees
float RotatePointX(float x, float y, float centerX, float centerY, float degrees) {
	float dx = x - centerX;
	float dy = y - centerY;
	return (Cos(degrees) * dx) - (Sin(degrees) * dy) + centerX;
}

//rotates Y about a center point by an amount of degrees
float RotatePointY(float x, float y, float centerX, float centerY, float degrees) {
	float dx = x - centerX;
	float dy = y - centerY;
	return (Sin(degrees) * dx) - (Cos(degrees) * dy) + centerY;
}

//scales X to centerX by a given scale
float ScalePointX(float x, float centerX, float scale) {
	return (scale * (x - centerX)) + centerX; 
}

//scales Y to centerY by a given scale
float ScalePointY(float y, float centerY, float scale) {
	return (scale * (y - centerY)) + centerY; 
}

//rotates and scales X about a center point by an amount of degrees
float RotateScalePointX(float x, float y, float centerX, float centerY, float degrees, float scaleX, float scaleY) {
	float dx = (x - centerX) * scaleX;
	float dy = (y - centerY) * scaleY;
	return (Cos(degrees) * dx) - (Sin(degrees) * dy) + centerX;
}

//rotates and scales Y about a center point by an amount of degrees
float RotateScalePointY(float x, float y, float centerX, float centerY, float degrees, float scaleX, float scaleY) {
	float dx = (x - centerX) * scaleX;
	float dy = (y - centerY) * scaleY;
	return (Sin(degrees) * dx) - (Cos(degrees) * dy) + centerY;
}


// Interpolates between p1 and p2 given 't' clamped within range 0,1.
float Lerp(float p1, float p2, float t) {
	return (p1 + (p2 - p1) * t);
}

// Returns the dot product of two vectors.
float DotProduct( float x1, float y1, float x2, float y2 ) {
	return (x1 * x2 + y1 * y2);
}

// Returns the cross product of two vectors.
float CrossProduct( float x1, float y1, float x2, float y2 ) {
	return (x1 * y2 - y1 * x2);
}

// Returns the squared distance of a vector.
float DistanceSquared( float x, float y ) {
	return (x * x + y * y);
}

// Finds the center of p1 and p2.
float Midpoint(float p1, float p2) {
	return Lerp(p1, p2, 0.5);
}

// Performs a "Smooth" Interpolation given 't' clamped within range 0,1.
float SmoothStep(float p1, float p2, float t) {
	t = (t * t) * (3.0 - (2.0 * t));
	return Lerp(p1, p2, t);
}

// Returns an angle pointing (t)percentage more accurate to the target than the specified radian_angle.
float TurnTowards( int X, int Y, int targetX, int targetY, float radian_angle, float t ) {
	float a = ArcTan( targetX - X, targetY - Y );
	float d = WrapAngle(a - radian_angle);
	if ( d > PI )
		d =-( PI2 - d );
	else if ( d < -PI )
		d = PI2 + d;
	return WrapAngle(radian_angle + d * t);
}

// Wraps radian value towards the range of -PI,PI.
float WrapAngle( float radians ) {
	while (radians <= -PI) radians += PI2;
	while (radians > PI) radians -= PI2;
	return radians;
}

// Wraps degree value towards the range of -180,180.
float WrapDegrees( float degrees ) {
	while (degrees <= -180) degrees += 360;
	while (degrees > 180) degrees -= 360;
	return degrees;
}

// Converts a counterclockwise degree angle (from -180 to 180) into one of the eight
// standard directions (DIR_UP etc.) used by ZC.
int AngleDir8(float angle) {
	if (angle <= 157.5 && angle > 112.5)
		return DIR_LEFTDOWN;
	else if (angle <= 112.5 && angle > 67.5)
		return DIR_DOWN;
	else if (angle <= 67.5 && angle > 22.5)
		return DIR_RIGHTDOWN;
	else if (angle <= 22.5 && angle > -22.5)
		return DIR_RIGHT;
	else if (angle <= -22.5 && angle > -67.5)
		return DIR_RIGHTUP;
	else if (angle <= -67.5 && angle > -112.5)
		return DIR_UP;
	else if (angle <= -112.5 && angle > -157.5)
		return DIR_LEFTUP;
	else
		return DIR_LEFT;
}

//The above, but for radian angles.
int RadianAngleDir8(float angle) {
	return AngleDir8(angle*57.2958);
}

// Converts a counterclockwise degree angle (from -180 to 180) into one of the four
// standard directions (DIR_UP, DIR_DOWN, DIR_LEFT, DIR_RIGHT) used by ZC.
int AngleDir4(float angle) {
	if (angle <= 135 && angle > 45)
		return DIR_DOWN;
	else if (angle <= 45 && angle > -45)
		return DIR_RIGHT;
	else if (angle <= -45 && angle > -135)
		return DIR_UP;
	else
		return DIR_LEFT;
}

//The above, but for radian angles.
int RadianAngleDir4(float angle) {
	return AngleDir4(angle*57.2958);
}

//Returns the opposite direction to angle 'dir'
int OppositeDir(int dir) {
	return Cond(dir < 4, dir^1b, dir^11b);
}

//Converts directions to go round in a circle rather than U, D, L, R
int SpinDir(int dir) {
	if(dir==0)
		return DIR_UP;
	else if(dir==1)
		return DIR_RIGHT;
	else if(dir==2)
		return DIR_DOWN;
	else if(dir==3)
		return DIR_LEFT;
	return -1;
}


//Draws an ffc to a given layer. If the ffc is larger than 1x1 its graphics must all be comboed
void DrawToLayer(ffc f, int layer, int opacity){
	Screen->DrawCombo(layer,f->X,f->Y,f->Data,f->TileWidth,f->TileHeight,f->CSet,-1,-1,0,0,0,-1,0,true,opacity);
}

//Draws an npc to a given layer
void DrawToLayer(npc n, int layer, int opacity){
	Screen->DrawTile(layer,n->X,n->Y,n->Tile,n->TileWidth,n->TileHeight,n->CSet,-1,-1,0,0,0,0,true,opacity);
}

//Draws an lweapon to a given layer
void DrawToLayer(lweapon l, int layer, int opacity){
	Screen->DrawTile(layer,l->X,l->Y,l->Tile,l->TileWidth,l->TileHeight,l->CSet,-1,-1,0,0,0,0,true,opacity);
}

//Draws an eweapon to a given layer
void DrawToLayer(eweapon e, int layer, int opacity){
	Screen->DrawTile(layer,e->X,e->Y,e->Tile,e->TileWidth,e->TileHeight,e->CSet,-1,-1,0,0,0,0,true,opacity);
}

//Draws an item to a given layer
void DrawToLayer(item i, int layer, int opacity){
	Screen->DrawTile(layer,i->X,i->Y,i->Tile,i->TileWidth,i->TileHeight,i->CSet,-1,-1,0,0,0,0,true,opacity);
}

//Generalized and optimized rectangle collision checking function.
//Returns true if the bounding box of box1 and box2 overlap.
bool RectCollision(int box1_x1, int box1_y1, int box1_x2, int box1_y2, int box2_x1, int box2_y1, int box2_x2, int box2_y2) {
	if( box1_y2 < box2_y1 ) return false;
	else if( box1_y1 > box2_y2 ) return false;
	else if( box1_x2 < box2_x1 ) return false;
	else if( box1_x1 > box2_x2 ) return false;
	return true;
}

//Check for collisions of two squares given upper-left coordinates and a side length for each.
bool SquareCollision(int c1x, int c1y, int side1, int c2x, int c2y, int side2) {
	return RectCollision(c1x, c1y, c1x+side1, c1y+side1, c2x, c2y, c2x+side2, c2y+side2);
}

//Check for collisions of two squares given center coordinates and a halved side length for each.
bool SquareCollision2(int c1x, int c1y, int radius1, int c2x, int c2y, int radius2) {
	if( c1y + radius1 < c2y - radius2 ) return false;
	else if( c1y - radius1 > c2y + radius2 ) return false;
	else if( c1x + radius1 < c2x - radius2 ) return false;
	else if( c1x - radius1 > c2x + radius2 ) return false;
	return true;
}

//Returns true if the two circles c1 and c2 overlap.
bool CircleCollision(int c1x, int c1y, int radius1, int c2x, int c2y, int radius2) {
	return (Distance(c1x,c1y,c2x,c2y) <= (radius1+radius2));
}

//Returns true if there is a collision between the hitboxes of an lweapon and an eweapon.
bool Collision(lweapon a, eweapon b) {
	int c[4];
	c[0] = a->X + a->HitXOffset;
	c[1] = b->X + b->HitXOffset;
	c[2] = a->Y + a->HitYOffset;
	c[3] = b->Y + b->HitYOffset;
	return RectCollision(c[0], c[2], c[0]+a->HitWidth, c[2]+a->HitHeight, c[1], c[3], c[1]+b->HitWidth, c[3]+b->HitHeight) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
}

//A collision between an lweapon and an lweapon.
bool Collision(lweapon a, lweapon b) {
	int c[4];
	c[0] = a->X + a->HitXOffset;
	c[1] = b->X + b->HitXOffset;
	c[2] = a->Y + a->HitYOffset;
	c[3] = b->Y + b->HitYOffset;
	return RectCollision(c[0], c[2], c[0]+a->HitWidth, c[2]+a->HitHeight, c[1], c[3], c[1]+b->HitWidth, c[3]+b->HitHeight) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
}

//A collision between an eweapon and an eweapon.
bool Collision(eweapon a, eweapon b) {
	int c[4];
	c[0] = a->X + a->HitXOffset;
	c[1] = b->X + b->HitXOffset;
	c[2] = a->Y + a->HitYOffset;
	c[3] = b->Y + b->HitYOffset;
	return RectCollision(c[0], c[2], c[0]+a->HitWidth, c[2]+a->HitHeight, c[1], c[3], c[1]+b->HitWidth, c[3]+b->HitHeight) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
}

//A collision between an lweapon and an npc.
bool Collision(lweapon a, npc b) {
	int c[4];
	c[0] = a->X + a->HitXOffset;
	c[1] = b->X + b->HitXOffset;
	c[2] = a->Y + a->HitYOffset;
	c[3] = b->Y + b->HitYOffset;
	return RectCollision(c[0], c[2], c[0]+a->HitWidth, c[2]+a->HitHeight, c[1], c[3], c[1]+b->HitWidth, c[3]+b->HitHeight) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
}

//A collision between an eweapon and an npc.
bool Collision(eweapon a, npc b) {
	int c[4];
	c[0] = a->X + a->HitXOffset;
	c[1] = b->X + b->HitXOffset;
	c[2] = a->Y + a->HitYOffset;
	c[3] = b->Y + b->HitYOffset;
	return RectCollision(c[0], c[2], c[0]+a->HitWidth, c[2]+a->HitHeight, c[1], c[3], c[1]+b->HitWidth, c[3]+b->HitHeight) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
}

//A collision between an npc and an npc.
bool Collision(npc a, npc b) {
	int c[4];
	c[0] = a->X + a->HitXOffset;
	c[1] = b->X + b->HitXOffset;
	c[2] = a->Y + a->HitYOffset;
	c[3] = b->Y + b->HitYOffset;
	return RectCollision(c[0], c[2], c[0]+a->HitWidth, c[2]+a->HitHeight, c[1], c[3], c[1]+b->HitWidth, c[3]+b->HitHeight) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
}

//A collision between an item and an lweapon.
bool Collision(item a, lweapon b) {
	int c[4];
	c[0] = a->X + a->HitXOffset;
	c[1] = b->X + b->HitXOffset;
	c[2] = a->Y + a->HitYOffset;
	c[3] = b->Y + b->HitYOffset;
	return RectCollision(c[0], c[2], c[0]+a->HitWidth, c[2]+a->HitHeight, c[1], c[3], c[1]+b->HitWidth, c[3]+b->HitHeight) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
}

//A collision between an item and an eweapon.
bool Collision(item a, eweapon b) {
	int c[4];
	c[0] = a->X + a->HitXOffset;
	c[1] = b->X + b->HitXOffset;
	c[2] = a->Y + a->HitYOffset;
	c[3] = b->Y + b->HitYOffset;
	return RectCollision(c[0], c[2], c[0]+a->HitWidth, c[2]+a->HitHeight, c[1], c[3], c[1]+b->HitWidth, c[3]+b->HitHeight) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
}

//A collision between an item and an npc.
bool Collision(item a, npc b) {
	int c[4];
	c[0] = a->X + a->HitXOffset;
	c[1] = b->X + b->HitXOffset;
	c[2] = a->Y + a->HitYOffset;
	c[3] = b->Y + b->HitYOffset;
	return RectCollision(c[0], c[2], c[0]+a->HitWidth, c[2]+a->HitHeight, c[1], c[3], c[1]+b->HitWidth, c[3]+b->HitHeight) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
}

//A collision between an item and an item.
bool Collision(item a, item b) {
	int c[4];
	c[0] = a->X + a->HitXOffset;
	c[1] = b->X + b->HitXOffset;
	c[2] = a->Y + a->HitYOffset;
	c[3] = b->Y + b->HitYOffset;
	return RectCollision(c[0], c[2], c[0]+a->HitWidth, c[2]+a->HitHeight, c[1], c[3], c[1]+b->HitWidth, c[3]+b->HitHeight) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
}

//A collision between an ffc and an lweapon. Uses TileWidth and TileHeight for the FFC's bounding box. Ignores the Z axis.
bool Collision(ffc f, lweapon b) {
	int c[2];
	c[0] = b->X + b->HitXOffset;
	c[1] = b->Y + b->HitYOffset;
	return RectCollision(f->X, f->Y, f->X+(f->TileWidth*16), f->Y+(f->TileHeight*16), c[0], c[1], c[0]+b->HitWidth, c[1]+b->HitHeight);
}

//A collision between an ffc and an eweapon. Uses TileWidth and TileHeight for the FFC's bounding box. Ignores the Z axis.
bool Collision(ffc f, eweapon b) {
	int c[2];
	c[0] = b->X + b->HitXOffset;
	c[1] = b->Y + b->HitYOffset;
	return RectCollision(f->X, f->Y, f->X+(f->TileWidth*16), f->Y+(f->TileHeight*16), c[0], c[1], c[0]+b->HitWidth, c[1]+b->HitHeight);
}

//A collision between an ffc and an npc. Uses TileWidth and TileHeight for the FFC's bounding box. Ignores the Z axis.
bool Collision(ffc f, npc b) {
	int c[2];
	c[0] = b->X + b->HitXOffset;
	c[1] = b->Y + b->HitYOffset;
	return RectCollision(f->X, f->Y, f->X+(f->TileWidth*16), f->Y+(f->TileHeight*16), c[0], c[1], c[0]+b->HitWidth, c[1]+b->HitHeight);
}

//A collision between an ffc and an item. Uses TileWidth and TileHeight for the FFC's bounding box. Ignores the Z axis.
bool Collision(ffc f, item b) {
	int c[2];
	c[0] = b->X + b->HitXOffset;
	c[1] = b->Y + b->HitYOffset;
	return RectCollision(f->X, f->Y, f->X+(f->TileWidth*16), f->Y+(f->TileHeight*16), c[0], c[1], c[0]+b->HitWidth, c[1]+b->HitHeight);
}

//A collision between an ffc and an ffc. Uses TileWidth and TileHeight for the FFCs' bounding boxes.
bool Collision(ffc f, ffc f2) {
	return RectCollision(f->X, f->Y, f->X+(f->TileWidth*16), f->Y+(f->TileHeight*16), f2->X, f2->Y, f2->X+f2->TileWidth*16, f2->Y+f2->TileHeight*16);
}

//A circular collision between an ffc and an ffc. Uses TileWidth and TileHeight to find the centre of the FFCs.
bool Collision(ffc f, int radius1, ffc f2, int radius2) {
	return CircleCollision(f->X+f->TileWidth/2, f->Y+f->TileHeight/2, radius1,f2->X+f2->TileWidth/2, f2->Y+f2->TileHeight/2, radius2);
}

// So that you don't have to remember the ordering of the args
bool Collision(eweapon a, lweapon b) {
	return Collision(b, a);
}

bool Collision(npc a, lweapon b) {
	return Collision(b, a);
}

bool Collision(npc a, eweapon b) {
	return Collision(b, a);
}

bool Collision(lweapon a, item b) {
	return Collision(b, a);
}

bool Collision(eweapon a, item b) {
	return Collision(b, a);
}

bool Collision(npc a, item b) {
	return Collision(b, a);
}

bool Collision(lweapon a, ffc b) {
	return Collision(b, a);
}

bool Collision(eweapon a, ffc b) {
	return Collision(b, a);
}

bool Collision(npc a, ffc b) {
	return Collision(b, a);
}

bool Collision(item a, ffc b) {
	return Collision(b, a);
}

// Returns true if there is a collision between Link's hitbox and the eweapon's.
// This only checks hitboxes.
bool LinkCollision(eweapon b) {
	int c[4];
	c[0] = Link->X + Link->HitXOffset;
	c[1] = b->X + b->HitXOffset;
	c[2] = Link->Y + Link->HitYOffset;
	c[3] = b->Y + b->HitYOffset;
	return RectCollision(c[0], c[2], c[0]+Link->HitWidth, c[2]+Link->HitHeight, c[1], c[3], c[1]+b->HitWidth, c[3]+b->HitHeight) && (Link->Z + Link->HitZHeight >= b->Z) && (Link->Z <= b->Z + b->HitZHeight);
}

// Returns true if there is a collision between Link's hitbox and the lweapon's.
// This only checks hitboxes.
bool LinkCollision(lweapon b) {
	int c[4];
	c[0] = Link->X + Link->HitXOffset;
	c[1] = b->X + b->HitXOffset;
	c[2] = Link->Y + Link->HitYOffset;
	c[3] = b->Y + b->HitYOffset;
	return RectCollision(c[0], c[2], c[0]+Link->HitWidth, c[2]+Link->HitHeight, c[1], c[3], c[1]+b->HitWidth, c[3]+b->HitHeight) && (Link->Z + Link->HitZHeight >= b->Z) && (Link->Z <= b->Z + b->HitZHeight);
}


// Returns true if there is a collision between Link's hitbox and the item's.
// This only checks hitboxes.
bool LinkCollision(item b) {
	int c[4];
	c[0] = Link->X + Link->HitXOffset;
	c[1] = b->X + b->HitXOffset;
	c[2] = Link->Y + Link->HitYOffset;
	c[3] = b->Y + b->HitYOffset;
	return RectCollision(c[0], c[2], c[0]+Link->HitWidth, c[2]+Link->HitHeight, c[1], c[3], c[1]+b->HitWidth, c[3]+b->HitHeight) && (Link->Z + Link->HitZHeight >= b->Z) && (Link->Z <= b->Z + b->HitZHeight);
}


// Returns true if there is a collision between Link's hitbox and the npc's.
// This only checks hitboxes.  Uses TileWidth and TileHeight to find the centre of the FFCs.
bool LinkCollision(npc b) {
	int c[4];
	c[0] = Link->X + Link->HitXOffset;
	c[1] = b->X + b->HitXOffset;
	c[2] = Link->Y + Link->HitYOffset;
	c[3] = b->Y + b->HitYOffset;
	return RectCollision(c[0], c[2], c[0]+Link->HitWidth, c[2]+Link->HitHeight, c[1], c[3], c[1]+b->HitWidth, c[3]+b->HitHeight) && (Link->Z + Link->HitZHeight >= b->Z) && (Link->Z <= b->Z + b->HitZHeight);
}


// Returns true if there is a collision between Link's hitbox and the FFC's.
// This only checks hitboxes.
bool LinkCollision(ffc f) {
	int c[2];
	c[0] = Link->X + Link->HitXOffset;
	c[1] = Link->Y + Link->HitYOffset;
	return RectCollision(f->X, f->Y, f->X+(f->TileWidth*16), f->Y+(f->TileHeight*16), c[0], c[1], c[0]+Link->HitWidth, c[1]+Link->HitHeight);
}

// Returns the X coordinate of the left edge of the hitbox.
int HitboxLeft(eweapon a) {
	return (a->X + a->HitXOffset);
}

int HitboxLeft(lweapon a) {
	return (a->X + a->HitXOffset);
}

int HitboxLeft(item a) {
	return (a->X + a->HitXOffset);
}

int HitboxLeft(npc a) {
	return (a->X + a->HitXOffset);
}

int HitboxLeft(ffc a) {
	return a->X;
}

// Returns the X coordinate of the right edge of the hitbox.
int HitboxRight(eweapon a) {
	return (a->X + a->HitXOffset + a->HitWidth - 1);
}

int HitboxRight(lweapon a) {
	return (a->X + a->HitXOffset + a->HitWidth - 1);
}

int HitboxRight(item a) {
	return (a->X + a->HitXOffset + a->HitWidth - 1);
}

int HitboxRight(npc a) {
	return (a->X + a->HitXOffset + a->HitWidth - 1);
}

int HitboxRight(ffc a) {
	return a->X + a->TileWidth*16 - 1;
}

// Returns the Y coordinate of the top edge of the hitbox.
int HitboxTop(eweapon a) {
	return (a->Y + a->HitYOffset);
}

int HitboxTop(lweapon a) {
	return (a->Y + a->HitYOffset);
}

int HitboxTop(item a) {
	return (a->Y + a->HitYOffset);
}

int HitboxTop(npc a) {
	return (a->Y + a->HitYOffset);
}

int HitboxTop(ffc a) {
	return a->Y;
}

// Returns the Y coordinate of the bottom edge of the hitbox.
int HitboxBottom(eweapon a) {
	return (a->Y + a->HitYOffset + a->HitHeight - 1);
}

int HitboxBottom(lweapon a) {
	return (a->Y + a->HitYOffset + a->HitHeight - 1);
}

int HitboxBottom(item a) {
	return (a->Y + a->HitYOffset + a->HitHeight - 1);
}

int HitboxBottom(npc a) {
	return (a->Y + a->HitYOffset + a->HitHeight - 1);
}

//Uses TileWidth and TileHeight for the FFC's bounding box. 
int HitboxBottom(ffc a) {
	return a->Y + (a->TileHeight*16) - 1;
}

//Returns the number of an FFC, and -1 for a non-valid FFC (which should never happen)
int FFCNum(ffc f) {
	for(int i=1; i<=32; i++)
		if(f == Screen->LoadFFC(i))
		return i;
	return -1;
}

//Functions for those who are not comfortable with binary
//Returns true if the left mouse button is pressed
bool InputLeftClick() {
	return (Link->InputMouseB&MB_LEFTCLICK) != 0;
}

//Returns true if the right mouse button is pressed
bool InputRightClick() {
	return (Link->InputMouseB&MB_RIGHTCLICK) != 0;
}

//Returns true if the central mouse button (if equipped) is pressed
bool InputMiddleClick() {
	return (Link->InputMouseB&MB_MIDDLECLICK) != 0;
}

//Returns the item ID of the item equipped to Link's A button
int GetEquipmentA() {
	return (Link->Equipment&0xFF);
}



//Returns the item ID of the item equipped to Link's B button
int GetEquipmentB() {
	return ((Link->Equipment&0xFF00)>>8);
}

//Returns true if Link is using item 'id'
bool UsingItem(int id){
	return (GetEquipmentA() == id && Link->InputA) || (GetEquipmentB() == id && Link->InputB);
}

//Returns the number of Triforce Pieces Link currently has
int NumTriforcePieces(){
	int ret = 0;
	for(int i=1;i<=8;i++)
		if(Game->LItems[i]&LI_TRIFORCE) ret++;
	return ret;
}



//Returns 1 if Screen Flag 'flag' is set from category 'category', 0 if it's not and -1 if an invalid flag is passed
//Flags are numbered starting from 0
int ScreenFlag(int category, int flag) {
	int catsizes[] = {3,7,5,3,2,4,4,2,3,7};
	if(flag < 0 || flag >= catsizes[category]) return -1;
	return Screen->Flags[category]&(1<<flag);
}

//Returns 1 if Screen Enemy Flag 'flag' is set from category 'category', 0 if it's not and -1 if an invalid flag is passed
//Flags are numbered starting from 0
int ScreenEFlag(int category, int flag) {
	int catsizes[] = {6,6,5};
	if(flag < 0 || flag >= catsizes[category]) return -1;
	return Screen->EFlags[category]&(1<<flag);
}

//Returns true if DMap Flag 'flag' is set on dmap 'dmap'
bool GetDMapFlag(int dmap, int flag){
	return (Game->DMapFlags[dmap]&flag)!=0;
}

//Sets a certain DMap flag to 'state'
void SetDMapFlag(int dmap, int flag, bool state){
	if(state) Game->DMapFlags[dmap] |= flag;
	else Game->DMapFlags[dmap] &= ~flag;
}

//Returns true if an item's Pickup state is set
//Use the IP_ constants for the 'pickup' argument of this function
bool GetItemPickup(item i, int pickup) {
	return (i->Pickup&pickup) != 0;
}

//Sets an item's Pickup state to 'state'
void SetItemPickup(item i, int pickup, bool state) {
	if(state) i->Pickup |= pickup;
	else i->Pickup &= ~pickup;
}

//Returns true if an npc's Misc. flag is set.
bool GetNPCMiscFlag(npc e, int flag) {
	return (e->MiscFlags&flag) != 0;
}

//Returns true if Link has the level item 'itm' from level 'level'
//Overloaded to use the current level if no 'level' arg is entered
//Use the LI_ constants for the 'itm' argument
bool GetLevelItem(int level, int itm) {
	return (Game->LItems[level]&itm) != 0;
}
bool GetLevelItem(int itm) {
	return (Game->LItems[Game->GetCurLevel()]&itm) != 0;
}
//Gives or removes a level item from Link's inventory
void SetLevelItem(int level, int itm, bool state) {
	if(state) Game->LItems[level] |= itm;
	else Game->LItems[level] &= ~itm;
}
void SetLevelItem(int itm, bool state) {
	if(state) Game->LItems[Game->GetCurLevel()] |= itm;
	else Game->LItems[Game->GetCurLevel()] &= ~itm;
}

//Create an NPC and set its X and Y position in one command
npc CreateNPCAt(int id, int x, int y) {
	npc nme = Screen->CreateNPC(id);
	if(nme->isValid()) {
		nme->X = x;
		nme->Y = y;
	}
	return nme;
}

//Create an Item and set its X and Y position in one command
item CreateItemAt(int id, int x, int y) {
	item it = Screen->CreateItem(id);
	if(it->isValid()) {
		it->X = x;
		it->Y = y;
	}
	return it;
}

//Create an LWeapon and set its X and Y position in one command
lweapon CreateLWeaponAt(int id, int x, int y) {
	lweapon lw = Screen->CreateLWeapon(id);
	if(lw->isValid()) {
		lw->X = x;
		lw->Y = y;
	}
	return lw;
}

//Create an EWeapon and set its X and Y position in one command
eweapon CreateEWeaponAt(int id, int x, int y) {
	eweapon ew = Screen->CreateEWeapon(id);
	if(ew->isValid()) {
		ew->X = x;
		ew->Y = y;
	}
	return ew;
}


//Creates an lweapon at 'distx,disty' away from where Link is facing
lweapon NextToLink(int id, int distx, int disty) {
	lweapon l = CreateLWeaponAt(id, Link->X+InFrontX(Link->Dir, distx), Link->Y+InFrontY(Link->Dir, disty));
	if(l->isValid()) {
    	l->Dir = Link->Dir;
	}
	return l;
}

//Creates an lweapon 'dist' pixels away from the front of Link
lweapon NextToLink(int id, int dist) {
	return NextToLink(id, dist, dist);
}

eweapon NextToNPC(npc n, int id, int distx, int disty) {
	eweapon e = CreateEWeaponAt(id, n->X+InFrontX(n->Dir, distx), n->Y+InFrontY(n->Dir, disty));
	if(e->isValid()) {
    	e->Dir = n->Dir;
	}
	return e;
}
eweapon NextToNPC(npc n, int id, int dist) {
	return NextToNPC(n, id, dist, dist);
}


//Aim-type constants, for use with AimEWeapon
//**Moved** to std_constants.zh

//Various methods for shooting at Link and at random
void AimEWeapon(eweapon e, int aimtype)
{
	int angle = RadianAngle(e->X, e->Y, Link->X, Link->Y);
	if(aimtype == AT_4DIR)
	{
		e->Dir = RadianAngleDir4(angle);
	}
	else if(aimtype == AT_8DIR)
	{
		e->Dir = RadianAngleDir8(angle);
	}
	else if(aimtype == AT_ANGULAR)
	{
		e->Angular = true;
		e->Angle = angle;
		e->Dir = RadianAngleDir8(angle);
	}
	else if(aimtype == AT_RAND4DIR)
	{
		e->Dir = Rand(4);
	}
	else if(aimtype == AT_RAND8DIR)
	{
		e->Dir = Rand(8);
	}
	else if(aimtype == AT_RANDANGULAR)
	{
		e->Angular = true;
		e->Angle = Randf(PI2);
		e->Dir = RadianAngleDir8(e->Angle);
	}
}

//Aiming at enemies and at random
void AimLWeapon(lweapon l, npc n, int aimtype)
{
	int angle = RadianAngle(l->X, l->Y, n->X, n->Y);
	if(aimtype == AT_4DIR)
	{
		l->Dir = RadianAngleDir4(angle);
	}
	else if(aimtype == AT_8DIR)
	{
		l->Dir = RadianAngleDir8(angle);
	}
	else if(aimtype == AT_ANGULAR)
	{
		l->Angular = true;
		l->Angle = angle;
		l->Dir = RadianAngleDir8(angle);
	}
	else
		AimLWeapon(l, aimtype);
}
void AimLWeapon(lweapon l, int aimtype)
{
	if(aimtype == AT_RAND4DIR)
	{
		l->Dir = Rand(4);
	}
	else if(aimtype == AT_RAND8DIR)
	{
		l->Dir = Rand(8);
	}
	else if(aimtype == AT_RANDANGULAR)
	{
		l->Angular = true;
		l->Angle = Randf(PI2);
		l->Dir = RadianAngleDir8(l->Angle);
	}
}

//Turns a WPN_ constant to an EW_ constant
int WeaponTypeToID(int wpnt)
{
	if(wpnt == WPN_ENEMYFLAME) 		return EW_FIRE;
	else if(wpnt == WPN_ENEMYWIND)		return EW_WIND;
	else if(wpnt == WPN_ENEMYFIREBALL)	return EW_FIREBALL;
	else if(wpnt == WPN_ENEMYARROW)		return EW_ARROW;
	else if(wpnt == WPN_ENEMYBRANG)		return EW_BRANG;
	else if(wpnt == WPN_ENEMYSWORD)		return EW_BEAM;
	else if(wpnt == WPN_ENEMYROCK)		return EW_ROCK;
	else if(wpnt == WPN_ENEMYMAGIC)		return EW_MAGIC;
	else if(wpnt == WPN_ENEMYBOMB)		return EW_BOMB;
	else if(wpnt == WPN_ENEMYSBOMB)		return EW_SBOMB;
	else if(wpnt == WPN_ENEMYLITBOMB)	return EW_BOMBBLAST;
	else if(wpnt == WPN_ENEMYLITSBOMB)	return EW_SBOMBBLAST;
	else if(wpnt == WPN_ENEMYFIRETRAIL)	return EW_FIRETRAIL;
	else if(wpnt == WPN_ENEMYFLAME2)	return EW_FIRE2;
	else if(wpnt == WPN_ENEMYFIREBALL2)	return EW_FIREBALL2;
	return -1;
}


//Removes LWeapon 'l' from the screen
void Remove(lweapon l){
	if(!l->isValid()) return;
	l->DeadState = WDS_DEAD;
	l->X = 32768;
}

//Removes EWeapon 'e' from the screen
void Remove(eweapon e){
	if(!e->isValid()) return;
	e->DeadState = WDS_DEAD;
	e->X = 32768;
}

//Removes Item 'i' from the screen
void Remove(item i){
	if(!i->isValid()) return;
	i->X = 32768;
}

//Removes NPC 'n' from the screen
void Remove(npc n){
	if(!n->isValid()) return;
	n->X = 32768;
	n->HP = -1000;
}

//Remove an FFC by zeroing out all of its attributes, and freeing it for other use. 
void Remove(ffc f){
	if ( f->Data == 0 && f->Script == 0 ) return;
	else {
		f->Data = 0;
		f->Script = 0;
		f->Script = 0;
		f->CSet = 0;
		f->Delay = 0;
		f->X = 0;
		f->Y = 0;
		f->Vx = 0;
		f->Vy = 0;
		f->Ax = 0;
		f->Ay = 0;
		for ( int q = 0; q < 10; q++ ) f->Flags[q] = 0;
		f->TileWidth = 0;
		f->TileHeight = 0;
		f->EffectWidth = 0;
		f->EffectHeight = 0;
		f->Link = 0;
		for ( int q = 0; q < 15; q++ ) f->Misc[q] = 0;
	}
}

//Creates a timeout item (like a rupee or heart)
item CreateTimeoutItem(int id, int x, int y) {
	item Spawn = Screen->CreateItem(id);
	SetItemPickup(Spawn, IP_TIMEOUT, true);
	Spawn->HitWidth = 16; Spawn->HitHeight = 16;
	Spawn->X = x; Spawn->Y = y;
}

//Creates a timeout item (like a rupee or heart)
//Allows constraining the HitWidth and HitHeight
item CreateTimeoutItem(int id, int x, int y, int width, int height) {
	item Spawn = Screen->CreateItem(id);
	SetItemPickup(Spawn, IP_TIMEOUT, true);
	Spawn->HitWidth = width; Spawn->HitHeight = height;
	Spawn->X = x; Spawn->Y = y;
}

// Use the I_ constants.
// Warning: these iterate over every onscreen item.
// Iterating over every onscreen lweapon multiple times per frame may
// cause slowdown in Zelda Classic.
int NumItemsOf(int type) {
	int ret = 0;
	item it;
	for (int i = Screen->NumItems(); i >0 ; i--) {
		it = Screen->LoadItem(i);
		if (it->ID == type)
		ret++;
	}
	return ret;
}


// Use the LW_ constants.
// Warning: these iterate over every onscreen lweapon.
// Iterating over every onscreen lweapon multiple times per frame may
// cause slowdown in Zelda Classic.
int NumLWeaponsOf(int type) {
	int ret = 0;
	lweapon w;
	for (int i = Screen->NumLWeapons(); i > 0; i--) {
		w = Screen->LoadLWeapon(i);
		if (w->ID == type)
		ret++;
	}
	return ret;
}

int NumEWeaponsOf(int type) {
	int ret = 0;
	eweapon w;
	for (int i = Screen->NumEWeapons(); i > 0; i--) {
		w = Screen->LoadEWeapon(i);
		if (w->ID == type)
		ret++;
	}
	return ret;
}

int NumNPCsOf(int type) {
	int ret = 0;
	npc n;
	for (int i = Screen->NumNPCs(); i > 0 ; i--) {
		n = Screen->LoadNPC(i);
		if (n->ID == type)
		ret++;
	}
	return ret;
}

// Returns the first LWeapon of the given type. Use the LW_ constants.
// If none exist, it returns an uninitialised pointer.
lweapon LoadLWeaponOf(int type) {
	lweapon w;
	for (int i=1; i <= Screen->NumLWeapons(); i++) {
		w = Screen->LoadLWeapon(i);
		if (w->ID == type) return w;
	}
	lweapon w2;
	return w2;
}

// Returns the first EWeapon of the given type. Use the EW_ constants.
// If none exist, it returns an uninitialised pointer.
eweapon LoadEWeaponOf(int type) {
	eweapon w;
	for (int i=1; i <= Screen->NumEWeapons(); i++) {
		w = Screen->LoadEWeapon(i);
		if (w->ID == type) return w;
	}
	eweapon w2;
	return w2;
}

// Returns the first NPC of the given type. Use the NPCT_ constants.
// If none exist, it returns an uninitialised pointer.
npc LoadNPCOfType(int type) {
	npc n;
	for (int i=1; i <= Screen->NumNPCs(); i++) {
		n = Screen->LoadNPC(i);
		if (n->Type == type) return n;
	}
	npc n2;
	return n2;
}

// Returns the first NPC of the given ID. Use the NPC_ constants.
// If none exist, it returns an uninitialised pointer.
npc LoadNPCOf(int type) {
	npc n;
	for (int i=1; i <= Screen->NumNPCs(); i++) {
		n = Screen->LoadNPC(i);
		if (n->ID == type) return n;
	}
	npc n2;
	return n2;
}

//Returns the position of the first instance of the given combo, or -1.
int FirstComboOf(int t, int layer) {
	for (int i = 0; i < 176; i++) {
		if (layer == 0) {
			if (Screen->ComboD[i] == t)
			return i;
		}
		else {
			if (GetLayerComboD(layer,i) == t)
			return i;
		}
	}
	return -1;
}

//Returns the position of the last instance of the given combo, or -1.
int LastComboOf(int t, int layer) {
	for (int i = 175; i >= 0; i--) {
		if (layer == 0) {
			if (Screen->ComboD[i] == t)
			return i;
		}
		else {
			if (GetLayerComboD(layer,i) == t)
			return i;
		}
	}
	return -1;
}

//Returns the position of the first instance of the given combo, or -1.
int FirstComboTypeOf(int t, int layer) {
	for (int i = 0; i < 176; i++) {
		if (layer == 0) {
			if (Screen->ComboT[i] == t)
			return i;
		}
		else {
			if (GetLayerComboT(layer,i) == t)
			return i;
		}
	}
	return -1;
}

//Returns the position of the last instance of the given combo, or -1.
int LastComboTypeOf(int t, int layer) {
	for (int i = 175; i >= 0; i--) {
		if (layer == 0) {
			if (Screen->ComboT[i] == t)
			return i;
		}
		else {
			if (GetLayerComboT(layer,i) == t)
			return i;
		}
	}
	return -1;
}

//Returns the position of the first instance of the given combo flag, or -1.
//Checks inherent flags too!
int FirstComboFlagOf(int t, int layer) {
	for (int i = 0; i < 176; i++) {
		if (layer == 0) {
			if (Screen->ComboF[i] == t || Screen->ComboI[i] == t) return i;
		}
		else {
			if (Game->GetComboFlag(Screen->LayerMap(layer), Screen->LayerScreen(layer),i) == t
			|| Game->GetComboInherentFlag(Screen->LayerMap(layer), Screen->LayerScreen(layer),i) == t)
			return i;
		}
	}
	return -1;
}

//Returns the position of the last instance of the given combo flag, or -1.
//Checks inherent flags too!
int LastComboFlagOf(int t, int layer) {
	for (int i = 175; i >= 0; i--) {
		if (layer == 0) {
			if (Screen->ComboF[i] == t || Screen->ComboI[i] == t) return i;
		}
		else {
			if (Game->GetComboFlag(Screen->LayerMap(layer), Screen->LayerScreen(layer),i) == t
			|| Game->GetComboInherentFlag(Screen->LayerMap(layer), Screen->LayerScreen(layer),i) == t)
			return i;
		}
	}
	return -1;
}

// Returns true if the combo at the given position is water.
bool IsWater(int position) {
	int combo=Screen->ComboT[position];
	if(combo==CT_WATER || combo==CT_SWIMWARP || combo==CT_DIVEWARP || (combo>=CT_SWIMWARPB && combo<=CT_DIVEWARPD))
		return true;
	else return false;
}

// Returns true if the combo at the given position is a pit.
bool IsPit(int position) {
	int combo=Screen->ComboT[position];
	if(combo==CT_PIT || combo==CT_PITR || (combo>=CT_PITB && combo<=CT_PITD))
		return true;
	else return false;
}

//Creates and returns an exact copy of the passed LWeapon. Assumes that the passed pointer is valid.
lweapon Duplicate(lweapon a) {
	lweapon b = Screen->CreateLWeapon(a->ID);
	b->X = a->X;
	b->Y = a->Y;
	b->Z = a->Z;
	b->Jump = a->Jump;
	b->Extend = a->Extend;
	b->TileWidth = a->TileWidth;
	b->TileHeight = a->TileHeight;
	b->HitWidth = a->HitWidth;
	b->HitHeight = a->HitHeight;
	b->HitZHeight = a->HitZHeight;
	b->HitXOffset = a->HitXOffset;
	b->HitYOffset = a->HitYOffset;
	b->DrawXOffset = a->DrawXOffset;
	b->DrawYOffset = a->DrawYOffset;
	b->DrawZOffset = a->DrawZOffset;
	b->Tile = a->Tile;
	b->CSet = a->CSet;
	b->DrawStyle = a->DrawStyle;
	b->Dir = a->Dir;
	b->OriginalTile = a->OriginalTile;
	b->OriginalCSet = a->OriginalCSet;
	b->FlashCSet = a->FlashCSet;
	b->NumFrames = a->NumFrames;
	b->Frame = a->Frame;
	b->ASpeed = a->ASpeed;
	b->Damage = a->Damage;
	b->Step = a->Step;
	b->Angle = a->Angle;
	b->Angular = a->Angular;
	b->CollDetection = a->CollDetection;
	b->DeadState = a->DeadState;
	b->Flash = a->Flash;
	b->Flip = a->Flip;
	for (int i = 0; i < 16; i++)
		b->Misc[i] = a->Misc[i];
	return b;
}

//Creates and returns an exact copy of the passed EWeapon. Assumes that the passed pointer is valid.
eweapon Duplicate(eweapon a) {
	eweapon b = Screen->CreateEWeapon(a->ID);
	b->X = a->X;
	b->Y = a->Y;
	b->Z = a->Z;
	b->Jump = a->Jump;
	b->Extend = a->Extend;
	b->TileWidth = a->TileWidth;
	b->TileHeight = a->TileHeight;
	b->HitWidth = a->HitWidth;
	b->HitHeight = a->HitHeight;
	b->HitZHeight = a->HitZHeight;
	b->HitXOffset = a->HitXOffset;
	b->HitYOffset = a->HitYOffset;
	b->DrawXOffset = a->DrawXOffset;
	b->DrawYOffset = a->DrawYOffset;
	b->DrawZOffset = a->DrawZOffset;
	b->Tile = a->Tile;
	b->CSet = a->CSet;
	b->DrawStyle = a->DrawStyle;
	b->Dir = a->Dir;
	b->OriginalTile = a->OriginalTile;
	b->OriginalCSet = a->OriginalCSet;
	b->FlashCSet = a->FlashCSet;
	b->NumFrames = a->NumFrames;
	b->Frame = a->Frame;
	b->ASpeed = a->ASpeed;
	b->Damage = a->Damage;
	b->Step = a->Step;
	b->Angle = a->Angle;
	b->Angular = a->Angular;
	b->CollDetection = a->CollDetection;
	b->DeadState = a->DeadState;
	b->Flash = a->Flash;
	b->Flip = a->Flip;
	for (int i = 0; i < 16; i++)
		b->Misc[i] = a->Misc[i];
	return b;
}

//This should allow any scripted object to easily mimic Link styled LOZ solidity collision
//checking, be it Link, FFCs, or enemies.
//Note - You should use full_tile=true if you don't want the upper eight pixels to overlap
//solid combos as per LOZ1 behavior.
bool CanWalk(int x, int y, int dir, int step, bool full_tile) {
	int c=8;
	int xx = x+15;
	int yy = y+15;
	if(full_tile) c=0;
	if(dir==0) return !(y-step<0||Screen->isSolid(x,y+c-step)||Screen->isSolid(x+8,y+c-step)||Screen->isSolid(xx,y+c-step));
	else if(dir==1) return !(yy+step>=176||Screen->isSolid(x,yy+step)||Screen->isSolid(x+8,yy+step)||Screen->isSolid(xx,yy+step));
	else if(dir==2) return !(x-step<0||Screen->isSolid(x-step,y+c)||Screen->isSolid(x-step,y+c+7)||Screen->isSolid(x-step,yy));
	else if(dir==3) return !(xx+step>=256||Screen->isSolid(xx+step,y+c)||Screen->isSolid(xx+step,y+c+7)||Screen->isSolid(xx+step,yy));
	return false; //invalid direction
}

//Returns true if Link is on a sideview screen
bool IsSideview() {
	return Screen->Flags[SF_ROOMTYPE] & 4;
}

//Returns true if Link is on a sideview screen
//bool IsSideviewFlag() {
//	return ScreenFlag(SF_ROOMTYPE, SFR_SIDEVIEW);
//}

//Returns true if Link is on a Dungeon (flagged) screen
bool IsDungeonFlag() {
	return Screen->Flags[SF_ROOMTYPE] & 1;
}

//Returns true if Link is on an Interior (flagged) screen
bool IsInteriorFlag() {
	return Screen->Flags[SF_ROOMTYPE] & 2;
}

//Returns true if Link is in a Dungeon Room
//int IsDungeon(){
//	return ScreenFlag(SF_ROOMTYPE, SFR_DUNGEON);
//}

//Returns true if Link is in an Interior Room
//int IsInterior(){
//	return ScreenFlag(SF_ROOMTYPE, SFR_INTERIOR);
//}

//Returns true if the sprite at (x,y) is standing on a sideview platform on a sideview screen, as worked out
//by ZC's internal code.
//For 16 pixel high sprites only.
bool OnSidePlatform(int x, int y) {
	return (Screen->isSolid(x+4,y+16) && Screen->isSolid(x+12,y+16) && Screen->Flags[SF_ROOMTYPE]&4);
}

//Returns true if a sprite of height 'h' at position (x,y) with an offset of (xOff,yOff) is standing
//on a sideview platform on a sideview screen.
bool OnSidePlatform(int x, int y, int xOff, int yOff, int h) {
	return (Screen->isSolid((x+xOff)+4,(y+yOff)+h) && Screen->isSolid((x+xOff)+12,(y+yOff)+h) && Screen->Flags[SF_ROOMTYPE]&4);
}

//Kills all of Link's inputs
void NoAction() {
	Link->InputUp = false; Link->PressUp = false;
	Link->InputDown = false; Link->PressDown = false;
	Link->InputLeft = false; Link->PressLeft = false;
	Link->InputRight = false; Link->PressRight = false;
	Link->InputR = false; Link->PressR = false;
	Link->InputL = false; Link->PressL = false;
	Link->InputA = false; Link->PressA = false;
	Link->InputB = false; Link->PressB = false;
	Link->InputEx1 = false; Link->PressEx1 = false;
	Link->InputEx2 = false; Link->PressEx2 = false;
	Link->InputEx3 = false; Link->PressEx3 = false;
	Link->InputEx4 = false; Link->PressEx4 = false;
}

//Kills all of Link's inputs
void NoAction(bool analogueStick) {
	Link->InputUp = false; Link->PressUp = false;
	Link->InputDown = false; Link->PressDown = false;
	Link->InputLeft = false; Link->PressLeft = false;
	Link->InputRight = false; Link->PressRight = false;
	Link->InputR = false; Link->PressR = false;
	Link->InputL = false; Link->PressL = false;
	Link->InputA = false; Link->PressA = false;
	Link->InputB = false; Link->PressB = false;
	Link->InputEx1 = false; Link->PressEx1 = false;
	Link->InputEx2 = false; Link->PressEx2 = false;
	Link->InputEx3 = false; Link->PressEx3 = false;
	Link->InputEx4 = false; Link->PressEx4 = false;
	
	if ( analogueStick ) {
		Link->InputAxisUp = false; Link->InputAxisRight = false; 
		Link->InputAxisDown = false; Link->InputAxisLeft = false; 
		Link->PressAxisUp = false; Link->PressAxisRight = false; 
		Link->PressAxisDown = false; Link->PressAxisLeft = false; 
	}
}


//NoAction, then Waitframe or (equivalent of) Waitframes
void WaitNoAction() {
	NoAction();
	Waitframe();
}

void WaitNoAction(int frames) {
	for(int i = 0; i < frames; i++)
		WaitNoAction();
}

//Get an NPC's name from an ID
void GetNPCName(int ID, int string) {
	npc n = Screen->CreateNPC(ID);
	n->GetName(string);
	Remove(n);
}

void GetMessage(int ID, int string) {
	Game->GetMessage(ID, string);
	int i;
	for(i = MAX_MESSAGELENGTH-2; string[i] == ' '; i--);
	string[i+1] = 0;
}

itemdata GetItemData(item i) {
	return Game->LoadItemData(i->ID);
}

int GetHighestLevelItem(int itemclass) {
	itemdata id;
	int ret = -1;
	int curlevel = -1000;
	//143 is default max items, increase if you add lots of your own
	for(int i = 0; i < 256; i++)
	{
		id = Game->LoadItemData(i);
		if(id->Family != itemclass)
			continue;
		if(id->Level > curlevel)
		{
			curlevel = id->Level;
			ret = i;
		}
	}
	return ret;
}

int GetHighestLevelItem(item i) {
	itemdata argid = GetItemData(i);
	int ret = i->ID;
	int curlevel = argid->Level;
	itemdata id;
	//143 is max items, decrease to improve speed if you need to
	for(int i = 0; i < 256; i++)
	{
		id = Game->LoadItemData(i);
		if(id->Family != argid->Family)
			continue;
		if(id->Level > curlevel)
		{
			curlevel = id->Level;
			ret = i;
		}
	}
	return ret;
}

// Convert between map and DMap screens
int DMapToMap(int screen, int dmap) {
	return screen+Game->DMapOffset[dmap];
}

int MapToDMap(int screen, int dmap) {
	return screen-Game->DMapOffset[dmap];
}

//Safe Sqrt functions if an irrational number would be involved.
//Returns '464' (square root of 215296), if the value passed is negative. 
//Returns '0' on Sqrt(0).
float SafeSqrt(float val){
	
	if ( STD_NEVER_USE_SAFESQRT ) return Sqrt(val);
	else {
		//if ( val > 214748.3648 ) val = 214748.3648;
		if ( val > 0 && val <= 214747.9999 ) return Sqrt(val);
		//Return a predesignated square root, instead of performing a Sqrt(MAX_INT) would be more optimised. 
		if ( val < 0 ) return 464; 	//! This is the smallest integer square root value possible 
						//! that is greater than the square root of MAX_INT.
						//! and would help identify errors.
		//if ( val < 0 ) return 463.4095; //The square root of 214798.3648
		//! We could also returm 363 here, which is the smallest square root over MAX_INT.
		//Returns the square root of MAX_INT if the value passed is a negative number. 
		//if ( val < 0 ) return Sqrt(214747.9999);
		return 0;
	}
}



//Returns square root of 'val'. Returns 'specifyNegRet' if a negative value is passed as 'val'. Returns '0' for Sqrt(0).
float SafeSqrt(float val, float specifyNegRet){
	if ( val > 214747.9999 ) val = 214747.9999;
	if ( val > 0 && val <= 214747.9999 ) return Sqrt(val);
	if ( val < 0 ) return specifyNegRet;
	return 0;
}

//Fairly select between true or false.
int ChooseB(){
	return Rand(0,1);
}

// Chooses one of the boolean options randomly and fairly.
bool ChooseB(bool a, bool b) {
	if (Rand(0,1)==0) return a;
	else return b;
}

bool ChooseB(bool a, bool b, bool c) {
	int r = Rand(0,2);
	if (r==0) return a;
	else if (r==1) return b;
	else return c;
}

bool ChooseB(bool a, bool b, bool c, bool d) {
	int r = Rand(0,3);
	if (r==0) return a;
	else if (r==1) return b;
	else if (r==2) return c;
	else return d;
}

bool ChooseB(bool a, bool b, bool c, bool d, bool e) {
	int r = Rand(0,4);
	if (r==0) return a;
	else if (r==1) return b;
	else if (r==2) return c;
	else if (r==3) return d;
	else return e;
}

bool ChooseB(bool a, bool b, bool c, bool d, bool e, bool f) {
	int r = Rand(0,5);
	if (r==0) return a;
	else if (r==1) return b;
	else if (r==2) return c;
	else if (r==3) return d;
	else if (r==4) return e;
	else return f;
}


//Trace the indices of an array, with a space between each. max 20 per line. 
//NOT overloaded to accept all array types. Trace() does nto work on ffc, item, itemdata, lweapon, or eweapon!
//Mayne next version. 
void TraceArray(int arr){
	TraceNL();
	int _spc[2]=" ";
	for ( int q = 0; q < SizeOfArray(arr); q++ ) {
		Trace(arr[q]); TraceS(_spc);
		if ( q % 10 == 0 ) TraceNL();
	}
}

//Trace the indices of a Boolean array, with a space between each. max 20 per line. 
void TraceArrayB(bool arr, int size){
	TraceNL();
	int _spc[2]=" ";
	for ( int q = 0; q < size; q++ ) {
		TraceB(arr[q]); TraceS(_spc);
		if ( q % 10 == 0 ) TraceNL();
	}
}

void TraceArray(int arr, bool verbose){
	if ( verbose ) 	{
		int str[]="Tracing array with Pointer: ";
		TraceNL(); TraceS(str); Trace(arr); TraceNL();

		for ( int q = 0; q < SizeOfArray(arr); q++ ) {
			int str2[]="Index: ";
			int str3[]="is : ";
			TraceS(str2); Trace(q); TraceS(str3); Trace(arr[q]);
			TraceNL();
		}
	}
	else {
		TraceNL();
		int _spc[2]=" ";
		for ( int q = 0; q < SizeOfArray(arr); q++ ) {
			Trace(arr[q]); TraceS(_spc);
			if ( q % 10 == 0 ) TraceNL();
		}
	}
}

//Trace the indices of a Boolean array, allows verbose logging.
void TraceArrayB(bool arr, int size, bool verbose){
	if ( verbose ) {
		//ZScript has no facility to read a pointer ID of an array with a type of bool, ffc, item, *weapon, or itemdata.
		//int str[]="Tracing array with Pointer: ";
		int str[]="Tracing Boolean Array: ";
		TraceNL(); TraceS(str); TraceNL();
		
		int _spc[2]=" ";
		for ( int q = 0; q < size; q++ ) {
			int str2[]="Index: ";
			int str3[]="is : ";
			TraceS(str2); Trace(q); TraceS(str3); TraceB(arr[q]); TraceS(_spc);
			TraceNL();
		}
	}
	else {
		TraceNL();
		int _spc[2]=" ";
		for ( int q = 0; q < size; q++ ) {
			TraceB(arr[q]); TraceS(_spc);
			if ( q % 10 == 0 ) TraceNL();
		}	
	}
}

//This doesn't work, as ZScript reads an invalid index as false, rather than not being able to read it. :(
//int SizeOfArrayB(bool arr){
//	int pass; 
//	for ( int q = 0; q < 214747; q++ ) {
//		int val = -1;
//		if ( arr[q] == true ) val = 1;
//		if ( arr[q] == false ) val = 0;
//		if ( arr[q] != true && arr[q] != false ) return pass;
//		pass++;
//	}
//}
		

//void TraceArray(float arr){
//	TraceNL();
//	int _spc[2]=" ";
//	for ( int q = 0; q < SizeOfArray(arr); q++ ) {
//		Trace(arr[q]); TraceS(_spc);
//		if ( q % 10 == 0 ) TraceNL();
//	}
//}

//void TraceArray(lweapon arr, int size){
//	TraceNL();
//	int _spc[2]=" ";
//	for ( int q = 0; q < size; q++ ) {
//		int id = arr[q];
//		Trace(id); TraceS(_spc);
//		if ( q % 10 == 0 ) TraceNL();
//	}
//}

//void TraceArray(eweapon arr, int size){
//	TraceNL();
//	int _spc[2]=" ";
//	for ( int q = 0; q < size; q++ ) {
//		Trace(arr[q]); TraceS(_spc);
//		if ( q % 10 == 0 ) TraceNL();
//	}
//}

//void TraceArray(npc arr, int size){
//	TraceNL();
//	int _spc[2]=" ";
//	for ( int q = 0; q < size; q++ ) {
//		Trace(arr[q]); TraceS(_spc);
//		if ( q % 10 == 0 ) TraceNL();
//	}
//}

//void TraceArray(ffc arr, int size){
///	TraceNL();
//	int _spc[2]=" ";
//	for ( int q = 0; q < size; q++ ) {
//		Trace(arr[q]); TraceS(_spc);
//		if ( q % 10 == 0 ) TraceNL();
//	}
//}

//void TraceArray(item arr, int size){
//	TraceNL();
//	int _spc[2]=" ";
//	for ( int q = 0; q < size; q++ ) {
//		Trace(arr[q]); TraceS(_spc);
//		if ( q % 10 == 0 ) TraceNL();
//	}
//}

//void TraceArray(itemdata arr, int size){
//	TraceNL();
//	int _spc[2]=" ";
//	for ( int q = 0; q < size; q++ ) {
//		Trace(arr[q]); TraceS(_spc);
//		if ( q % 10 == 0 ) TraceNL();
//	}
//}


//Trace each index of an array, and print strings to make them legible.
//void TraceArray(int arr){
//	int str[]="Tracing array with Pointer: ";
//	int bufferPointer[7]=" ";
//	itoa(arr,bufferPointer);
//	int mainBuffer[40]=" ";
//	strcat(str,mainBuffer);
//	strcat(bufferPointer,mainBuffer);
//	TraceNL();
//	TraceS(mainBuffer);
//	TraceNL();

//	for ( int q = 0; q <= SizeOfArray(arr); q++ ) {
//		int str2[]="Index: ";
//		int str3[]="is : ";
//		int buffer[22]=" ";
//		int bufferAmt[7]=" ";
//		int bufferIndex[7]=" ";
//		itoa(arr[q],bufferAmt);
//		itoa(q,bufferIndex);
//		strcat(str2,buffer);
//		strcat(bufferIndex,buffer);
//		strcat(str3,buffer);
//		strcat(bufferAmt,buffer);
//		TraceS(buffer);
//		TraceNL();
//	}
//}

//Shorthand for TraceArray()
void TraceA(bool arr,int size){TraceArrayB(arr,size);}
void TraceA(float arr){TraceArray(arr);}
//void TraceA(npc arr,int size){TraceArray(arr,size);}
//void TraceA(ffc arr,int size){TraceArray(arr,size);}
//void TraceA(lweapon arr,int size){TraceArray(arr,size);}
//void TraceA(eweapon arr,int size){TraceArray(arr,size);}
//void TraceA(item arr,int size){TraceArray(arr,size);}
//void TraceA(itemdata arr,int size){TraceArray(arr,size);}

//Safely sets an equipment item, without lagging ZC. 
//Sets an item 'itm' true if it is false, and false if it is true.
void SetLinkItem(int itm){
	if ( !Link->Item[itm] ) Link->Item[itm] = true;
	else if ( Link->Item[itm] ) Link->Item[itm] = false;
}

//Sets an item 'itm' to the boolean value of 'state'.
void SetLinkItem(int itm, bool state){
	if ( !Link->Item[itm] && state ) Link->Item[itm] = true;
	else if ( Link->Item[itm] && !state ) Link->Item[itm] = false;
}

//Randomly returns true, or false. 
bool RandB(){
	int a = Rand(0,1);
	if ( a == 0 ) return false;
	else return true;
}


//Randomly returns true, or false, using input percentTrue to determine the percentage change of a 'true return'
bool RandB(int percentTrue){
	int a = Rand(1,100);
	if ( a <= percentTrue ) return true;
	else return false;
}


//Terminate an FFC, and set all its properties to 0. 
void EndFFC(int ffc_id){
	ffc f = Screen->LoadFFC(ffc_id);
	f->Data = 0;
	f->Script = 0;
	f->CSet = 0;
	f->Delay = 0;
	f->X = 0;
	f->Y = 0;
	f->Vx = 0;
	f->Vy = 0;
	f->Ax = 0;
	f->Ay = 0;
	for ( int q = 0; q < 10; q++ ) f->Flags[q] = 0;
	f->TileWidth = 0;
	f->TileHeight = 0;
	f->EffectWidth = 0;
	f->EffectHeight = 0;
	f->Link = 0;
	for ( int q = 0; q < 15; q++ ) f->Misc[q] = 0;
	//Quit(); If this is called from a global script, it would be bad. 
}


//Terminate an FFC, and set all its properties to 0. 
void EndFFC(ffc f){
	f->Data = 0;
	f->Script = 0;
	f->CSet = 0;
	f->Delay = 0;
	f->X = 0;
	f->Y = 0;
	f->Vx = 0;
	f->Vy = 0;
	f->Ax = 0;
	f->Ay = 0;
	for ( int q = 0; q < 10; q++ ) f->Flags[q] = 0;
	f->TileWidth = 0;
	f->TileHeight = 0;
	f->EffectWidth = 0;
	f->EffectHeight = 0;
	f->Link = 0;
	for ( int q = 0; q < 15; q++ ) f->Misc[q] = 0;
	//Quit(); If this is called from a global script, it would be bad. 
}

//Negates engine knockback for Link on land, or in water.
void NoLinkKnockback(){
	if ( Link->Action == LA_GOTHURTLAND || Link->Action == LA_GOTHURTWATER ) Link->HitDir = -1;
}

//Negates engine knockback for Link only on land.
void NoLinkKnockbackLand(){
	if ( Link->Action == LA_GOTHURTLAND ) Link->HitDir = -1;
}

//Negates engine knockback for Link only in water.
void NoLinkKnockbackWater(){
	if ( Link->Action == LA_GOTHURTWATER ) Link->HitDir = -1;
}



//Draws a screen specified by 'sourceMap and sourceScreen;, from layers specified by 'layerMin and layerMax', 
//at a desired opacity, to the layer specified by 'destLayer' of the current screen.
void ScreenToLayer(int sourceMap, int sourceScreen, int layerMin, int layerMax, int drawOpacity, int destLayer){
	for (int i = layerMin; i < layerMax; i++){
		Screen->DrawLayer(destLayer, sourceMap, sourceScreen, i, 0, 0, 0, drawOpacity);
	}
}

//Draws all layers of a screen specified by 'sourceMap and sourceScreen;,
//at a desired opacity, to the layer specified by 'destLayer' of the current screen.
void ScreenToLayer(int sourceMap, int sourceScreen, int drawOpacity, int destLayer){
	for (int i = 0; i < 6; i++){
		Screen->DrawLayer(destLayer, sourceMap, sourceScreen, i, 0, 0, 0, drawOpacity);
	}
}


//Accepts two inputs, and returns a float where the integer portion
//is the first inout, and the decimal portion is the second.
//Inputs will be automatically truncated, and scaled, as needed. 
int SetHighLowFloat(int integer_side, int decimal_side){
	if ( decimal_side >= 0 )
		decimal_side = (decimal_side << 0)/10000;
	if ( integer_side < 0 ) integer_side = integer_side*10000;
	else integer_side = integer_side << 0;
	return integer_side+decimal_side;
}

//Accepts a variable, and a value as input, and returns the variable 
//with the decimal portion replaced with 'value'.
//If value is an integer, it will be divided by 10000. 
//If it is a decimal, it will be translated directly. 
int SetLowFloat(int variable, int value){
	int n = variable << 0;
	if ( value >= 0 )
		value = (value << 0)/10000;
	return n+value;
}

//Accepts a variable and a value and returns the variable with its integer
//portion replaced with 'value'. 
//If value is an integer, it will be truncated automatically. 
//If 'value' is a decimal, it will be multipied by 10000. 
int SetHighFloat(int variable, int value){
	int n = variable - ( variable << 0 );
	if ( value < 0 ) value = value*10000;
	else value = value << 0;
	return n+value;
}

//Takes a float as input 'n', and returns the integer portion as int. 
int GetHighFloat(int n) {
	return n >> 0;
}

//Takes a float as input 'n', and returns the decimal portion as int. 
int GetLowFloat(int n) {
	return (n - (n >> 0)) * 10000;
}

//Converts floating point value 'v', after the decimal, to an integer.
int DecimalToInt(int v) {
	int r = (v - (v << 0)) * 10000;
	return r;
}

//Truncates decimal off floating point value 'v'.
int Truncate(int v) {
	return ( v << 0 );
}

//Returns the number of valid integer places in a value. 
int NumPlacesInt(int var){
	int q; int num; int numzero; int n;
	for ( q = 0; q <= 4; q++ ) {
		n = GetDigit(var, q);
		if ( n == 0 ) numzero++;
		if ( n != 0 ) {
			num++;
			num+=numzero;
			numzero=0;
		}
	}
	return num;
}


//Returns the number of valid decimal places in a value. 
int NumPlacesDec(int var){
	int q; int num; int numzero; int n;
	for ( q = -1; q >= -4; q-- ) {
		n = GetDigit(var, q);
		if ( n == 0 ) numzero++;
		if ( n != 0 ) {
			num++;
			num+=numzero;
			numzero=0;
		}
	}
	return num;
}

int GetDigit(int n, int place){ return GetDigitValue(n,place);}

//Stores a single-sigit value into a specified place in a variable. 
//n is the variable input, place is the place, from a range of 4 to -4
//Storing a value that is larger than can fit in the specified number of places will return an error and -1.
int SetDigit(int v, int place, int value){
	int err[]="Error: The value specified to SetDigit() may only be one place wide.";
	value = value>>0; 
	if ( NumPlacesInt(value) > 1 ) {
		TraceS(err);
		return -1;
	}
	place = Clamp(place, -4, 4);
	int n; int q; 
	for ( q = -4; q <= 4; q++ ) {
		if ( q != place ) {
			n += GetDigit(v, q); //Store the individual values, except what we want to replace. 
		}
		if ( q == place ) { 
			n += (value * Pow(10,place)); //Store what we want to replace. 
		}
	}
	return n;
}

int SetDigitValue(int v, int place, int value){ return SetDigit(v, place, value); }

//Stores a value into a specified number of places in a variable. 
//n is the variable input, place is the initial place, from a range of 4 to -4
//num is the number of places, and value is the value to store in those places.
//Storing a value that is larger than can fit in the specified number of places will return an error and -1.
int SetPartialValue(int n, int place, int num, int value){
	place = Clamp(place, -4, 4);
	int r; int r2 = value << 0;
	
	int err[]="Error: The value specified to SetPartialValue() is wider than the specified value of 'num_places'.";
	//int err2[]="Error: The maximum input value for SetPartialValue(n, place, 
	if ( NumPlacesInt(r2) > num ) {
		TraceS(err);
		return -1;
	}
	
	int err2[]="Error: The value specified to SetPartialValue() is narrower than the specified value of 'num_places'.";
	//int err2[]="Error: The maximum input value for SetPartialValue(n, place, 
	if ( NumPlacesInt(r2) > num ) {
		TraceS(err2);
		num = NumPlacesInt(r2);
	}
	
	int err3[]="Error: You specified a floating point input 'value' to SetPartialValue() that was truncated.";
	if ( NumPlacesDec(value) > 0 ) {
		TraceS(err3);
	}
	
	int p = 0; int q; int minplace = place-num;
	minplace = Clamp(minplace,-4,4);
	int maxplace; int temp;
	
	//populate r with the values that we want
	for ( q = place; q >= minplace; q-- ) {
		temp = GetDigit(r2, p);
		SetDigit(r, q, temp); 
		p++;
	}
	//then setDigit the rest of its places using n
	for ( q = minplace; q >= -4; q++ ) {
		SetDigit(r, q, n);
	}
	for ( q = place+1; q <= 4; q++ ) {
		SetDigit(r, q, n);
	}
	return r;
	
	
}
//Extracts a single digit from n at the place specified. 
//-4 is the ten-thousandTHs place, 0 is the ones spot, and 4 is the ten-thousanDs spot. 
int GetDigitValue(int n, int place){
	place = Clamp(place, -4, 4);
	if( place < 0 ){
		n = DecimalToInt(n);
		place += 4;
	}

	int r = ((n / Pow(10, place)) % 10) << 0;
	return r;
}

//Extracts an integer using specific places of any value 'n', from position 'place' plus a number of places 'num'.
int GetPartialValue(int n, int place, int num){
	place = Clamp(place, -4, 4);
	int r;
	int adj = 1;
	for(int i = num-1; i > -1; i--){
		if(place - i < -4) continue;
		r += GetDigitValue(n, place - i) * adj;
		adj *= 10;
	}
	return r;
}

//Xor comparison of two boolean values. 
bool Xor(bool valA, bool valB){
	if ( !valA && valB ) return true;
	else if ( valA && !valB ) return true;
	return false;
}

//Collision functions, to avoid errors when using Collision() where LinkCOllision() is needed. 

bool Collision(ffc f) {
	return LinkCollision(f);
}

bool Collision(npc n){
	return LinkCollision(n);
}

bool Collision(lweapon l){
	return LinkCollision(l);
}

bool Collision(eweapon e){
	return LinkCollision(e);
}

bool Collision(item i){
	return LinkCollision(i);
}

//Returns a multiplication factor for ->Step based on direction.
// Specifically, return the x component of a line with a length of 1 extending
// in the given direction from origin.
//Step = step * DirX(dir);
//Valid only if dir is 0 to 7.

int DirX(int dir) {
	// Is a diagonal.
	if (dir & 100b) return Cond(dir & 001b, Sin(45), Sin(45)*-1);
	// Is horizontal.
	if (dir & 010b) return Cond(dir & 001b, 1, -1);
	return 0;
}

//Returns a multiplication factor for ->Step based on direction.
//Step = step * DirY(dir);
//Valid only if dir is 0 to 7.
// Specifically, return the y component of a line with a length of 1 extending
// in the given direction from origin.
int DirY(int dir) {
	// Is a diagonal.
	if (dir & 100b) return Cond(dir & 010b, Sin(45), Sin(45)*-1);
	// Is vertical.
	if (!(dir & 010b)) return Cond(dir & 001b, 1, -1);
	return 0;
}

//Matching - Comparison Functions: use an array (list) of values, and compare against a pointer, or pointer variable. 

//Match a given lweapon to the contents of an array 'list'
//Returns true of any of the entries on the list match. 
bool MatchLWeaponType(int list, lweapon l){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( l->ID == list[q] ) match = true;
	}
	return match;
}

//Match a given eweapon to the contents of an array 'list'
//Returns true of any of the entries on the list match. 
bool MatchEWeaponType(int list, eweapon e){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( e->ID == list[q] ) match = true;
	}
	return match;
}

//Match a given npc ID number to the contents of an array 'list'
//Returns true of any of the entries on the list match. 
bool MatchNPC(int list, npc n){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( n->ID == list[q] ) match = true;
	}
	return match;
}

//Match a given NPC TYPE to the contents of an array 'list'
//Returns true of any of the entries on the list match. 
bool MatchNPCT(int list, npc n){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( n->Type == list[q] ) match = true;
	}
	return match;
}

//Match a given item ID number to the contents of an array 'list'
//Returns true of any of the entries on the list match. 
bool MatchItem(int list, item i){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( i->ID == list[q] ) match = true;
	}
	return match;
}

//Match the present Link->Action to those on array 'list'.
//Returns true of any of the entries on the list match. 
//Checks if the present Link->Action is one from a predefined list.
bool MatchAction(int list){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( Link->Action == list[q] ) match = true;
	}
	return match;
}

//Compares combo 'cmb' and compares it to the values in array 'list'. 
//Returns true of any of the entries on the list match its Data. 
bool MatchComboD(int list, int cmb){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( Screen->ComboD[cmb] == list[q] ) match = true;
	}
	return match;
}

//Compares combo 'cmb' and compares it to the values in array 'list'. 
//Returns true of any of the entries on the list match its Type.
bool MatchComboT(int list, int cmb){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( Screen->ComboT[cmb] == list[q] ) match = true;
	}
	return match;
}

//Compares combo 'cmb' and compares it to the values in array 'list'. 
//Returns true of any of the entries on the list match its CSet.
bool MatchComboC(int list, int cmb){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( Screen->ComboC[cmb] == list[q] ) match = true;
	}
	return match;
}

//Compares combo 'cmb' and compares it to the values in array 'list'. 
//Returns true of any of the entries on the list match its Flag.
bool MatchComboF(int list, int cmb){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( Screen->ComboF[cmb] == list[q] ) match = true;
	}
	return match;
}

//Compares combo 'cmb' and compares it to the values in array 'list'. 
//Returns true of any of the entries on the list match its Inherent Flag.
bool MatchComboI(int list, int cmb){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( Screen->ComboI[cmb] == list[q] ) match = true;
	}
	return match;
}

//Compares combo 'cmb' and compares it to the values in array 'list'. 
//Returns true of any of the entries on the list match its Solidity.
bool MatchComboS(int list, int cmb){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( Screen->ComboS[cmb] == list[q] ) match = true;
	}
	return match;
}

//Compares combo 'cmb' on Layer 'layer' and compares it to the values in array 'list'. 
//Returns true of any of the entries on the list match its Data. 
bool MatchLayerComboD(int list, int layer, int cmb){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( GetLayerComboD(layer,cmb) == list[q] ) match = true;
	}
	return match;
}

//Compares combo 'cmb' on Layer 'layer' and compares it to the values in array 'list'. 
//Returns true of any of the entries on the list match its Type.
bool MatchLayerComboT(int list, int layer, int cmb){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( GetLayerComboT(layer,cmb) == list[q] ) match = true;
	}
	return match;
}

//Compares combo 'cmb' on Layer 'layer' and compares it to the values in array 'list'. 
//Returns true of any of the entries on the list match its CSet.
bool MatchLayerComboC(int list, int layer, int cmb){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( GetLayerComboC(layer,cmb) == list[q] ) match = true;
	}
	return match;
}

//Compares combo 'cmb' on Layer 'layer' and compares it to the values in array 'list'. 
//Returns true of any of the entries on the list match its Flag.
bool MatchLayerComboF(int list, int layer, int cmb){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( GetLayerComboF(layer,cmb) == list[q] ) match = true;
	}
	return match;
}

//Compares combo 'cmb' on Layer 'layer' and compares it to the values in array 'list'. 
//Returns true of any of the entries on the list match its Inherent Flag.
bool MatchLayerComboI(int list, int layer, int cmb){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( GetLayerComboI(layer,cmb) == list[q] ) match = true;
	}
	return match;
}

//Compares combo 'cmb' on Layer 'layer' and compares it to the values in array 'list'. 
//Returns true of any of the entries on the list match its Solidity.
bool MatchLayerComboS(int list, int layer, int cmb){
	bool match = false;
	for ( int q = 0; q < SizeOfArray(list); q++ ) {
		if ( GetLayerComboS(layer,cmb) == list[q] ) match = true;
	}
	return match;
}

//Matches a running ffc script to script_id. Returns true if they match.
int MatchScript(int script_id){
	for ( int q = 1; q < 32; q++ ) {
		ffc MatchScript = Screen->LoadFFC(q);
		if ( MatchScript->Script == script_id ) return q;
	}
	return 0;
}

//Compares the scripts of all running ffcs, to all indices of an array 'list' searching for
//a match to ffc script 'script_id'.
//If there is a match, it MatchScript() will return the first match (FFC number) found. 
int MatchScript(int script_id, int list){
	bool match;
	for ( int q = 1; q < 32; q++ ) {
		ffc MatchScript = Screen->LoadFFC(q);
		for ( int w = 0; w < SizeOfArray(list); w++ ) {
			if ( MatchScript->Script == script_id ) return q;
		}
	}
	return 0;
}


//Returns if Link has the Triforce piece for a given level.
int HasTriforce(int level){
        if(Game->LItems[level]&LI_TRIFORCE) return 1;
	return 0;
}

//Returns if Link has the compass for a given level.
int HasCompass(int level){
        if(Game->LItems[level]&LI_COMPASS) return 1;
	return 0;
}

//Returns if Link has the map for a given level.
int HasMap(int level){
        if(Game->LItems[level]&LI_MAP) return 1;
	return 0;
}

//Returns if Link has the map for a given level.
int HasBossKey(int level){
        if(Game->LItems[level]&LI_BOSSKEY) return 1;
	return 0;
}

//Returns if Link has defeated the dungeon boss for a given level.
int DefeatedLevelBoss(int level){
        if(Game->LItems[level]&LI_BOSS) return 1;
	return 0;
}

//Returns the item ID for the current screen, if there is one. 
int ScreenItem(){
	if ( Screen->RoomType == RT_SPECIALITEM ) return Screen->RoomData;
	return -1;
}

//Returns the number of Level Keys Link currently has for a specific level
//int NumTriforcePieces(int level){
  //  int ret = 0;
    //for(int i=1;i<=8;i++)
      //  if(Game->LItems[level]&LI_TRIFORCE) ret++;
    //return ret;
//}

//Returns the number of Triforce Pieces Link currently has.
//Specify the highest level in your game with arg 'maxlevel'.
int NumTriforcePieces(int maxlevel){
    int ret = 0;
    for(int i=1;i<=maxlevel;i++)
        if(Game->LItems[i]&LI_TRIFORCE) ret++;
    return ret;
}

//Sets the values for combo at position 'pos' to those specified. Pass -1 to leave a value unchanged.
void SetCombo(int pos, int data, int type, int flag, int inh_flag, int cset, int solid){
	if ( data >=0 ) Screen->ComboD[pos] = data;
	if ( type >= 0 ) Screen->ComboT[pos] = type;
	if ( flag >= 0 ) Screen->ComboF[pos] = flag;
	if ( inh_flag >= 0 ) Screen->ComboI[pos] = inh_flag;
	if ( cset >= 0 ) Screen->ComboC[pos] = cset;
	if ( solid >= 0 ) Screen->ComboS[pos] = solid;
}

//Sets the values for a combo on layer 'layer', at position 'pos' to the values specified.
//Pass -1 to any value to leave it unchanged. 
void SetLayerComboValues(int layer, int pos, int data, int type, int flag, int inh_flag, int cset, int solid){
	if ( data >=0 ) SetLayerComboD(layer,pos,data);
	if ( type >= 0 ) SetLayerComboT(layer,pos,type);
	if ( flag >= 0 ) SetLayerComboF(layer,pos,flag);
	if ( inh_flag >= 0 ) SetLayerComboI(layer,pos,inh_flag);
	if ( cset >= 0 ) SetLayerComboC(layer,pos,cset);
	if ( solid >= 0 ) SetLayerComboS(layer,pos,solid);
}

//Clones combo from position 'pos_a' to position 'pos_b'
void CloneCombo(int pos_a, int pos_b){
	Screen->ComboD[pos_b] = Screen->ComboD[pos_a];
	Screen->ComboT[pos_b] = Screen->ComboT[pos_a];
	Screen->ComboF[pos_b] = Screen->ComboF[pos_a];
	Screen->ComboI[pos_b] = Screen->ComboI[pos_a];
	Screen->ComboC[pos_b] = Screen->ComboC[pos_a];
	Screen->ComboS[pos_b] = Screen->ComboS[pos_a];
}

//Clones combo on layer 'layer' posigtion 'pos_a' to the same layer at position 'pos_b'
void CloneLayerCombo(int layer, int pos_a, int pos_b){
	SetLayerComboD(layer,pos_b,GetLayerComboD(layer,pos_a));
	SetLayerComboT(layer,pos_b,GetLayerComboT(layer,pos_a));
	SetLayerComboF(layer,pos_b,GetLayerComboF(layer,pos_a));
	SetLayerComboI(layer,pos_b,GetLayerComboI(layer,pos_a));
	SetLayerComboC(layer,pos_b,GetLayerComboC(layer,pos_a));
	SetLayerComboS(layer,pos_b,GetLayerComboS(layer,pos_a));
}

//Clones a combo on layer 'layer_a' at position 'pos_a', to layer 'layer_b" at position 'pos_b'.
void CloneLayerCombo(int layer_a, int layer_b, int pos_a, int pos_b){
	SetLayerComboD(layer_b,pos_b,GetLayerComboD(layer_a,pos_a));
	SetLayerComboT(layer_b,pos_b,GetLayerComboT(layer_a,pos_a));
	SetLayerComboF(layer_b,pos_b,GetLayerComboF(layer_a,pos_a));
	SetLayerComboI(layer_b,pos_b,GetLayerComboI(layer_a,pos_a));
	SetLayerComboC(layer_b,pos_b,GetLayerComboC(layer_a,pos_a));
	SetLayerComboS(layer_b,pos_b,GetLayerComboS(layer_a,pos_a));
}
	

///// 2016

//int DirRev(int dir) {
//	int bypassshields = 0;
//	if ( dir > 7 ) {
//		bypassshields = 8;
//		dir = dir - 8;
//	}
//	if ( dir == DIR_LEFT) return DIR_RIGHT + bypassshields;
//	if ( dir == DIR_DOWN) return DIR_UP + bypassshields;
//	if ( dir == DIR_UP) return DIR_DOWN + bypassshields;
//	if ( dir == DIR_RIGHT) return DIR_LEFT + bypassshields;
//	if ( dir == DIR_LEFTUP) return DIR_RIGHTDOWN + bypassshields;
//	if ( dir == DIR_RIGHTDOWN) return DIR_LEFTUP + bypassshields;
//	if ( dir == DIR_LEFTDOWN) return DIR_RIGHTUP + bypassshields;
//	if ( dir == DIR_RIGHTUP) return DIR_LEFTDOWN + bypassshields;
//}
	

int DirRev(int dir) {
	if ( dir == DIR_LEFT) return DIR_RIGHT;
	if ( dir == DIR_DOWN) return DIR_UP;
	if ( dir == DIR_UP) return DIR_DOWN;
	if ( dir == DIR_RIGHT) return DIR_LEFT;
	if ( dir == DIR_LEFTUP) return DIR_RIGHTDOWN;
	if ( dir == DIR_RIGHTDOWN) return DIR_LEFTUP;
	if ( dir == DIR_LEFTDOWN) return DIR_RIGHTUP;
	if ( dir == DIR_RIGHTUP) return DIR_LEFTDOWN;
}
	

int SpeedRev(int speed, int reduceinertia){
	if ( speed > 0 ) speed = ((speed * -1) + reduceinertia);
	if ( speed < 0 ) speed = ((speed * -1) - reduceinertia);
	return speed;
}

//Accepts the mass, and velocity if two objects. Determins the acceleration on impact. 
//Returns the net change that would affect both objects. 
int ImpactVelocity(int mass1, int velocity1, int mass2, int velociy2 ) { //, int time){ //time is sed here, as the amount of time that both objects are in contact.
	int momentum1 = mass1*velocity1; //mv1
	int momentum2 = mass2*velociy2; //mv2
	//int accel1;
	//int accel2;
	return momentum1 - momentum2;
}

//Accepts the mass, and velocity if two objects. Determins the acceleration on impact. 
//Returns the change of acceleration for object 'B'. 
int ImpactVelocityA(int massA, int velocityA, int massB, int velociyB ) { //, int time){ //time is sed here, as the amount of time that both objects are in contact.
	int momentumA = massA*velocityA; //mv1
	int momentumB = massB*velociyB; //mv2
	return momentumA - momentumB;
}

//Accepts the mass, and velocity if two objects. Determins the acceleration on impact. 
//Returns the change of acceleration for object 'B'.
int ImpactVelocityB(int massA, int velocityA, int massB, int velociyB ) { //, int time){ //time is sed here, as the amount of time that both objects are in contact.
	int momentumA = massA*velocityA; //mv1
	int momentumB = massB*velociyB; //mv2
	return momentumB - momentumA;
}

//Accepts the mass, and velocity if two weapons. Determins the acceleration on impact. 
//Changes the Step of both to reflect their mass on collision. 
void ImpactVelocity(lweapon a, eweapon b, int massA, int velocityA, int massB, int velociyB ) { //, int time){ //time is sed here, as the amount of time that both objects are in contact.
	int momentumA = massA*velocityA; //mv1
	int momentumB = massB*velociyB; //mv2
	int accelA = momentumA - momentumB;
	int accelB = momentumB - momentumA;
	a->Step += accelA;
	b->Step += accelB;
}

void ImpactVelocityF(){} //FFC version that will change the direction, and speed of moving ffcs on collision. 

//Returns centre of lweapon, with option to use either its actual coordinates, or those of its sprite. 
//Set 'usehitbox' true to use the hitbox centre, or false to use the sprite centre. 
int CenterX(lweapon anLWeapon, bool usehitbox) { 
	if ( usehitbox ) return anLWeapon->X+anLWeapon->HitWidth/2 + anLWeapon->HitXOffset;
	else return anLWeapon->X+8*anLWeapon->TileWidth + anLWeapon->DrawXOffset;
}

//Returns centre of lweapon, with option to use either its actual coordinates, or those of its sprite. 
//Set 'usehitbox' true to use the hitbox centre, or false to use the sprite centre. 
int CenterY(lweapon anLWeapon, bool usehitbox) {
	if ( usehitbox ) return anLWeapon->Y+anLWeapon->HitHeight/2 + anLWeapon->HitYOffset;
	else return  anLWeapon->Y+8*anLWeapon->TileHeight + anLWeapon->DrawYOffset;
}

//Returns centre of eweapon, with option to use either its actual coordinates, or those of its sprite. 
//Set 'usehitbox' true to use the hitbox centre, or false to use the sprite centre. 
int CenterX(eweapon anEWeapon, bool usehitbox) { 
	if ( usehitbox ) return anEWeapon->X+anEWeapon->HitWidth/2 + anEWeapon->HitXOffset;
	else return  anEWeapon->X+8*anEWeapon->TileWidth + anEWeapon->DrawXOffset;
}

//Returns centre of eweapon, with option to use either its actual coordinates, or those of its sprite. 
//Set 'usehitbox' true to use the hitbox centre, or false to use the sprite centre. 
int CenterY(eweapon anEWeapon, bool usehitbox) {
	if ( usehitbox ) return anEWeapon->Y+anEWeapon->HitHeight/2 + anEWeapon->HitYOffset;
	else return anEWeapon->Y+8*anEWeapon->TileHeight + anEWeapon->DrawYOffset;
}

//Returns centre of npc, with option to use either its actual coordinates, or those of its sprite. 
//Set 'usehitbox' true to use the hitbox centre, or false to use the sprite centre. 
int CenterX(npc n, bool usehitbox) { 
	if ( usehitbox ) return n->X+n->HitWidth/2 + n->HitXOffset;
	else return n->X+8*n->TileWidth + n->DrawXOffset;
}

//Returns centre of npc, with option to use either its actual coordinates, or those of its sprite. 
//Set 'usehitbox' true to use the hitbox centre, or false to use the sprite centre. 
int CenterY(npc n, bool usehitbox) {
	if ( usehitbox ) return n->Y+n->HitHeight/2 + n->HitYOffset;
	else return n->Y+8*n->TileHeight + n->DrawYOffset;
}

//Returns centre of npc, with option to use either its actual coordinates, or those of its sprite. 
//Set 'usehitbox' true to use the hitbox centre, or false to use the sprite centre. 
int CenterX(item i, bool usehitbox) { 
	if ( usehitbox ) return i->X+i->HitWidth/2 + i->HitXOffset;
	else return i->X+8*i->TileWidth + i->DrawXOffset;
}

//Returns centre of npc, with option to use either its actual coordinates, or those of its sprite. 
//Set 'usehitbox' true to use the hitbox centre, or false to use the sprite centre. 
int CenterY(item i, bool usehitbox) {
	if ( usehitbox ) return i->Y+i->HitHeight/2 + i->HitYOffset;
	else return i->X+8*i->TileHeight + i->DrawYOffset;
}


////////////////

//Returns centre of lweapon, with option to include its HitXOffset and DrawXOffset (individually).
//Set 'usehitbox' true to use the hitbox centre, or false to use the sprite centre. 
int CenterX(lweapon anLWeapon, bool usehitbox, bool trueoffset, bool drawoffset) { 
	int lx = anLWeapon->X;
	if ( usehitbox ) lx += anLWeapon->HitWidth/2;
	if ( !usehitbox ) lx += 8*anLWeapon->TileWidth;
	if ( trueoffset ) lx += anLWeapon->HitXOffset;
	if ( drawoffset ) lx += anLWeapon->DrawXOffset;
	return lx;
}

//Returns centre of lweapon, with option to include its HitYOffset and DrawYOffset (individually).
//Set 'usehitbox' true to use the hitbox centre, or false to use the sprite centre. 
int CenterY(lweapon anLWeapon, bool usehitbox, bool trueoffset, bool drawoffset) { 
	int ly = anLWeapon->Y;
	if ( usehitbox ) ly += anLWeapon->HitHeight/2;
	if ( !usehitbox ) ly += 8*anLWeapon->TileHeight;
	if ( trueoffset ) ly += anLWeapon->HitYOffset;
	if ( drawoffset ) ly += anLWeapon->DrawYOffset;
	return ly;
}

//Returns centre of eweapon, with option to include its HitXOffset and DrawXOffset (individually).
//Set 'usehitbox' true to use the hitbox centre, or false to use the sprite centre. 
int CenterX(eweapon anEWeapon, bool usehitbox, bool trueoffset, bool drawoffset) { 
	int ex = anEWeapon->X;
	if ( usehitbox ) ex += anEWeapon->HitWidth/2;
	if ( !usehitbox ) ex += 8*anEWeapon->TileWidth;
	if ( trueoffset ) ex += anEWeapon->HitXOffset;
	if ( drawoffset ) ex += anEWeapon->DrawXOffset;
	return ex;
}

//Returns centre of eweapon, with option to include its HitYOffset and DrawYOffset (individually).
//Set 'usehitbox' true to use the hitbox centre, or false to use the sprite centre. 
int CenterY(eweapon anEWeapon, bool usehitbox, bool trueoffset, bool drawoffset) { 
	int ey = anEWeapon->Y;
	if ( usehitbox ) ey += anEWeapon->HitHeight/2;
	if ( !usehitbox ) ey += 8*anEWeapon->TileHeight;
	if ( trueoffset ) ey += anEWeapon->HitYOffset;
	if ( drawoffset ) ey += anEWeapon->DrawYOffset;
	return ey;
}

//Returns centre of npc, with option to include its HitXOffset and DrawXOffset (individually).
//Set 'usehitbox' true to use the hitbox centre, or false to use the sprite centre. 
int CenterX(npc n, bool usehitbox, bool trueoffset, bool drawoffset) { 
	int nx = n->X;
	if ( usehitbox ) nx += n->HitWidth/2;
	if ( !usehitbox ) nx += 8*n->TileWidth;
	if ( trueoffset ) nx += n->HitXOffset;
	if ( drawoffset ) nx += n->DrawXOffset;
	return nx;
}

//Returns centre of npc, with option to include its HitYOffset and DrawYOffset (individually).
//Set 'usehitbox' true to use the hitbox centre, or false to use the sprite centre. 
int CenterY(npc n, bool usehitbox, bool trueoffset, bool drawoffset) { 
	int ny = n->Y;
	if ( usehitbox ) ny += n->HitHeight/2;
	if ( !usehitbox ) ny += 8*n->TileHeight;
	if ( trueoffset ) ny += n->HitYOffset;
	if ( drawoffset ) ny += n->DrawYOffset;
	return ny;
}

//Returns centre of item, with option to include its HitXOffset and DrawXOffset (individually).
//Set 'usehitbox' true to use the hitbox centre, or false to use the sprite centre. 
int CenterX(item i, bool usehitbox, bool trueoffset, bool drawoffset) { 
	int ix = i->X;
	if ( usehitbox ) ix += i->HitWidth/2;
	if ( !usehitbox ) ix += 8*i->TileWidth;
	if ( trueoffset ) ix += i->HitXOffset;
	if ( drawoffset ) ix += i->DrawXOffset;
	return ix;
}

//Returns centre of item, with option to include its HitYOffset and DrawYOffset (individually).
//Set 'usehitbox' true to use the hitbox centre, or false to use the sprite centre. 
int CenterY(item i, bool usehitbox, bool trueoffset, bool drawoffset) { 
	int iy = i->Y;
	if ( usehitbox ) iy += i->HitHeight/2;
	if ( !usehitbox ) iy += 8*i->TileHeight;
	if ( trueoffset ) iy += i->HitYOffset;
	if ( drawoffset ) iy += i->DrawYOffset;
	return iy;
}

////////////////

//We need to modify these functions to allow the same options as the non-Link versions. g

int CenterLinkX(bool hitoffset) { 
	if ( hitoffset ) return Link->X + 8 * Link->TileWidth + Link->HitXOffset;
	else return Link->X + 8 * Link->TileWidth;
}

int CenterLinkY(bool hitoffset) {
	if ( hitoffset ) return Link->Y + 8 * Link->TileHeight + Link->HitYOffset;
	else return Link->Y + 8 * Link->TileHeight;
}

int CenterLinkX(bool hitoffset, bool drawoffset) { 
	int lx = Link->X + 8 * Link->TileWidth;
	if ( hitoffset ) lx += Link->HitXOffset;
	if ( drawoffset ) lx += Link->DrawXOffset;	
	return lx;
}

int CenterLinkY(bool hitoffset, bool drawoffset) {
	int ly = Link->Y + 8 * Link->TileHeight;
	if ( hitoffset ) ly += Link->HitYOffset;
	if ( drawoffset ) ly += Link->DrawYOffset;	
	return ly;
}


//Returns the direction of the vector from (0, 0) to point, in degrees from -180 to 180. (0 = right)
float Angle(int x, int y) {
  return ArcTan(x, y)*57.2958;
}

//Added: CenterX(item anItem) and CenterY(item anItem) 06-Jan-2016

//Returns the centre coordinates of a combo at position 'loc' similar to Center*() functions, and ComboX/Y.
int CenterComboX(int loc){
	return (loc%16*16) + 8;
}

int CenterComboY(int loc){
	return (loc&0xF0) +8;
}

bool Collision(ffc f, int cmb) { return Collision(cmb,f); }
bool Collision(lweapon l, int cmb) { return Collision(cmb,l); }
bool Collision(eweapon e, int cmb) { return Collision(cmb,e); }
bool Collision(npc n, int cmb) { return Collision(cmb,n); }
bool Collision(item i, int cmb) { return Collision(cmb,i); }



//Check for collision between lweapon 'l' and a combo at location 'cmb'. 
//Set checkcoldetection to true if you wish to return false from an lweapon with ColDetection disabled. 
bool Collision(lweapon l, int cmb, bool checkcoldetection) { 
	if ( checkcoldetection && !l->CollDetection ) return false;
	else return Collision(cmb,l); 
}

bool Collision(int cmb, lweapon l, bool checkcoldetection) { 
	if ( checkcoldetection && !l->CollDetection ) return false;
	else return Collision(cmb,l); 
}


//Check for collision between eweapon 'e' and a combo at location 'cmb' . 
//Set checkcoldetection to true if you wish to return false from an eweapon with ColDetection disabled. 
bool Collision(eweapon e, int cmb, bool checkcoldetection) {
	if ( checkcoldetection && !e->CollDetection ) return false;
	else return Collision(cmb,e); 
}


bool Collision(int cmb, eweapon e, bool checkcoldetection) {
	if ( checkcoldetection && !e->CollDetection ) return false;
	else return Collision(cmb,e); 
}

//Check for collision between NPC 'n' and a combo at location 'cmb' . 
//Set checkcoldetection to true if you wish to return false from an NPC with ColDetection disabled. 
bool Collision(npc n, int cmb, bool checkcoldetection) { 
	if ( checkcoldetection && !n->CollDetection ) return false;
	else return Collision(cmb,n); 
}

bool Collision(int cmb, npc n, bool checkcoldetection) { 
	if ( checkcoldetection && !n->CollDetection ) return false;
	else return Collision(cmb,n); 
}

//Check for collision between Link and a combo at location 'cmb' . 
//Set checkcoldetection to true if you wish to return false from an NPC with ColDetection disabled. 
bool Collision(int cmb, bool checkcoldetection) {
	if ( checkcoldetection && !Link->CollDetection ) return false;
	else return Collision(cmb); 
}

//Check for collision between ffc 'f' and a combo at location 'cmb'. 
bool Collision(int cmb, ffc f){
	int c[8];
	c[0] = ComboX(cmb);
	c[1] = ComboY(cmb);
	c[2] = ComboX(cmb)+16;
	c[3] = ComboY(cmb)+16;
	c[4] = (f->X);
	c[5] = (f->Y);
	c[6] = c[4]+(f->EffectWidth);
	c[7] = c[5]+(f->EffectHeight);
	return RectCollision( c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7] );
}

//Check for collision between lweapon 'l' and a combo at location 'cmb'. 
bool Collision(int cmb, lweapon l){
	int c[8];
	c[0] = ComboX(cmb);
	c[1] = ComboY(cmb);
	c[2] = ComboX(cmb)+16;
	c[3] = ComboY(cmb)+16;
	c[4] = (l->X)+l->HitXOffset+l->DrawXOffset;
	c[5] = (l->Y)+l->HitYOffset+l->DrawYOffset;
	c[6] = c[4]+l->HitWidth;
	c[7] = c[5]+l->HitHeight;
	return RectCollision( c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7] );
}

//Check for collision between eweapon 'e' and a combo at location 'cmb'. 
bool Collision(int cmb, eweapon e){
	int c[8];
	c[0] = ComboX(cmb);
	c[1] = ComboY(cmb);
	c[2] = ComboX(cmb)+16;
	c[3] = ComboY(cmb)+16;
	c[4] = (e->X)+e->HitXOffset+e->DrawXOffset;
	c[5] = (e->Y)+e->HitYOffset+e->DrawYOffset;
	c[5] = c[4]+e->HitWidth;
	c[7] = c[5]+e->HitHeight;
	return RectCollision( c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7] );
}

//Check for collision between npc 'n' and a combo at location 'cmb'. 
bool Collision(int cmb, npc n){
	int c[8];
	c[0] = ComboX(cmb);
	c[1] = ComboY(cmb);
	c[2] = ComboX(cmb)+16;
	c[3] = ComboY(cmb)+16;
	c[4] = (n->X)+n->HitXOffset+n->DrawXOffset;
	c[5] = (n->Y)+n->HitYOffset+n->DrawYOffset;
	c[6] = c[4]+n->HitWidth;
	c[7] = c[5]+n->HitHeight;
	return RectCollision( c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7] );
}

//Check for collision between item 'i' and a combo at location 'cmb'. 
bool Collision(int cmb, item i){
	int c[8];
	c[0] = ComboX(cmb);
	c[1] = ComboY(cmb);
	c[2] = ComboX(cmb)+16;
	c[3] = ComboY(cmb)+16;
	c[4] = (i->X)+i->HitXOffset+i->DrawXOffset;
	c[5] = (i->Y)+i->HitYOffset+i->DrawYOffset;
	c[6] = c[4]+i->HitWidth;
	c[7] = c[5]+i->HitHeight;
	return RectCollision( c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7] );
}


//Check for collision between Link and a combo at location 'cmb'. 
bool Collision(int cmb){
	int c[4];
	c[0] = Link->X+Link->HitXOffset+Link->DrawXOffset;
	c[1] = Link->Y+Link->HitYOffset+Link->DrawYOffset;
	c[2] = c[0]+(Link->HitWidth);
	c[3] = c[1]+(Link->HitHeight);
	if ( !RectCollision( ComboX(cmb), ComboY(cmb), (ComboX(cmb)+16), (ComboY(cmb)+16), c[0], c[1], c[2], c[3]) ) return false;
	else if ( !(Distance(CenterLinkX(), CenterLinkY(), (ComboX(cmb)+8), (ComboY(cmb)+8)) < 8) ) return false;
	return true;
}

//Returns angle of the given direction.
int DirAngle(int dir){
	dir &=7;
	if (dir==DIR_UP) return 90;
	if (dir==DIR_DOWN) return 270;
	if (dir==DIR_LEFT) return 180;
	if (dir==DIR_RIGHT) return 0;
	if (dir==DIR_LEFTUP) return 135;
	if (dir==DIR_RIGHTUP) return 45;
	if (dir==DIR_LEFTDOWN) return 225;
	if (dir==DIR_RIGHTDOWN) return 315;
	return -1;
}

//Same as DirAngle, but return value is measured in radians.
int DirRad(int dir){
	return DirAngle(dir)*0.0174;
}

//Use SetCombo* on Layer 0 using LayerMap()
//A shorthand way to set a combo on the current layer.
//Layer 0 is the screen itself.
//Set layer0 to true to use LayerMap() to handle layer 0 combos. This should allow changes to remain static. 
void SetLayerComboD(int layer, int pos, int combo, bool layer0) {
	if (layer==0 && !layer0) Screen->ComboD[pos] = combo;
	else Game->SetComboData(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos, combo);
}


//A shorthand way to set a combo flag on the current layer.
//Layer 0 is the screen itself.
//Set layer0 to true to use LayerMap() to handle layer 0 combos. This should allow changes to remain static. 
void SetLayerComboF(int layer, int pos, int flag, bool layer0) {
	if (layer==0 && !layer0) Screen->ComboF[pos] = flag;
	else Game->SetComboFlag(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos, flag);
}

//Layer 0 is the screen itself.
//Set layer0 to true to use LayerMap() to handle layer 0 combos. This should allow changes to remain static. 
void SetLayerComboI(int layer, int pos, int flag, bool layer0) {
	if (layer==0 && !layer0) Screen->ComboI[pos] = flag;
	else Game->SetComboInherentFlag(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos, flag);
}


//A shorthand way to set a combo CSet on the current layer.
//Layer 0 is the screen itself.
//Set layer0 to true to use LayerMap() to handle layer 0 combos. This should allow changes to remain static. 
void SetLayerComboC(int layer, int pos, int cset, bool layer0) {
	if (layer==0 && !layer0) Screen->ComboC[pos] = cset;
	else Game->SetComboCSet(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos, cset);
}


//A shorthand way to set a combo type on the current layer.
//Layer 0 is the screen itself.
//Set layer0 to true to use LayerMap() to handle layer 0 combos. This should allow changes to remain static. 
void SetLayerComboT(int layer, int pos, int type, bool layer0) {
	if (layer==0 && !layer0) Screen->ComboT[pos] = type;
	else Game->SetComboType(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos, type);
}


//A shorthand way to set a combo's solidity on the current layer.
//Layer 0 is the screen itself.
//Set layer0 to true to use LayerMap() to handle layer 0 combos. This should allow changes to remain static. 
void SetLayerComboS(int layer, int pos, int solidity, bool layer0) {
	if (layer==0 && !layer0) Screen->ComboS[pos] = solidity;
	if ( MIN_CONSTANT > -214747.9999 ) { //Not compile don 2.50.3
		if ( layer == 1 ) 
		Game->SetComboSolid(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos, solidity);
		else if ( layer > 1 ) {
			int str[]="Setting solidity on layers higher than 1 causes this version of ZC to crash.";
			TraceS(str);
		}
	}
	else Game->SetComboSolid(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos, solidity);
}

//Read link's HitBox values
int HitboxTop() {
  return (Link->Y + Link->HitYOffset);
}

int HitboxLeft() {
  return (Link->X + Link->HitXOffset);
}

int HitboxRight() {
  return (Link->X + Link->HitXOffset + Link->HitWidth - 1);
}

int HitboxBottom() {
  return (Link->Y + Link->HitYOffset + Link->HitHeight - 1);
}

//! We need to add versions for every object type, too. 


//! Array memory management Utilities
//now in mem.zh
	
//Converts the ID (type) of a given weapon to its opposite class. 
//Returns -1 if the type is illegal.
int EWeaponToLWeaponID(int type){
	if ( type == EW_ARROW ) return LW_ARROW;
	if ( type == EW_BRANG ) return LW_BRANG;
	if ( type == EW_BEAM ) return LW_BEAM;
	if ( type == EW_MAGIC ) return LW_MAGIC;
	if ( type == EW_BOMB ) return LW_BOMB;
	if ( type == EW_BOMBBLAST ) return LW_BOMBBLAST;
	if ( type == EW_SBOMB ) return LW_SBOMB;
	if ( type == EW_SBOMBBLAST ) return LW_SBOMBBLAST;
	if ( type == EW_WIND ) return LW_WIND;
	if ( type >= 31 && type <= 40 ) return type;
	else return -1;
}

//Converts the ID (type) of a given weapon to its opposite class. 
//Returns -1 if the type is illegal.
int LWeaponToEWeaponID(int type){
	if ( type == LW_ARROW ) return EW_ARROW;
	if ( type == LW_BRANG ) return EW_BRANG;
	if ( type == LW_BEAM ) return EW_BEAM;
	if ( type == LW_MAGIC ) return EW_MAGIC;
	if ( type == LW_BOMB ) return EW_BOMB;
	if ( type == LW_BOMBBLAST ) return EW_BOMBBLAST;
	if ( type == LW_SBOMB ) return EW_SBOMB;
	if ( type == LW_SBOMBBLAST ) return EW_SBOMBBLAST;
	if ( type == LW_WIND ) return EW_WIND;
	if ( type >= 31 && type <= 40 ) return type;
	else return -1;
}


//Copy the attributes of a given lweapon to an eweapon.
//Returns -1 on error, including if the type (weap->ID) conversion is illegal.
eweapon LWeaponToEWeapon(lweapon a, eweapon b){
	int type = LWeaponToEWeaponID(a->ID);
	//if ( type == -1 ) return type;
	b->ID = type;
	b->X = a->X;
	b->Y = a->Y;
	b->Z = a->Z;
	b->Jump = a->Jump;
	b->Extend = a->Extend;
	b->TileWidth = a->TileWidth;
	b->TileHeight = a->TileHeight;
	b->HitWidth = a->HitWidth;
	b->HitHeight = a->HitHeight;
	b->HitZHeight = a->HitZHeight;
	b->HitXOffset = a->HitXOffset;
	b->HitYOffset = a->HitYOffset;
	b->DrawXOffset = a->DrawXOffset;
	b->DrawYOffset = a->DrawYOffset;
	b->DrawZOffset = a->DrawZOffset;
	b->Tile = a->Tile;
	b->CSet = a->CSet;
	b->DrawStyle = a->DrawStyle;
	b->Dir = a->Dir;
	b->OriginalTile = a->OriginalTile;
	b->OriginalCSet = a->OriginalCSet;
	b->FlashCSet = a->FlashCSet;
	b->NumFrames = a->NumFrames;
	b->Frame = a->Frame;
	b->ASpeed = a->ASpeed;
	b->Damage = a->Damage;
	b->Step = a->Step;
	b->Angle = a->Angle;
	b->Angular = a->Angular;
	b->CollDetection = a->CollDetection;
	b->DeadState = a->DeadState;
	b->Flash = a->Flash;
	b->Flip = a->Flip;
	for (int i = 0; i < 16; i++)
		b->Misc[i] = a->Misc[i];
	return b;
}



//Copy the attributes of a given lweapon to a new eweapon.
//Returns -1 on error, including if the type (weap->ID) conversion is illegal.
eweapon LWeaponToEWeapon(lweapon a){
	int type = LWeaponToEWeaponID(a->ID);
//	if ( type == -1 ) return type;
	eweapon b = Screen->CreateEWeapon(type);
	b->X = a->X;
	b->Y = a->Y;
	b->Z = a->Z;
	b->Jump = a->Jump;
	b->Extend = a->Extend;
	b->TileWidth = a->TileWidth;
	b->TileHeight = a->TileHeight;
	b->HitWidth = a->HitWidth;
	b->HitHeight = a->HitHeight;
	b->HitZHeight = a->HitZHeight;
	b->HitXOffset = a->HitXOffset;
	b->HitYOffset = a->HitYOffset;
	b->DrawXOffset = a->DrawXOffset;
	b->DrawYOffset = a->DrawYOffset;
	b->DrawZOffset = a->DrawZOffset;
	b->Tile = a->Tile;
	b->CSet = a->CSet;
	b->DrawStyle = a->DrawStyle;
	b->Dir = a->Dir;
	b->OriginalTile = a->OriginalTile;
	b->OriginalCSet = a->OriginalCSet;
	b->FlashCSet = a->FlashCSet;
	b->NumFrames = a->NumFrames;
	b->Frame = a->Frame;
	b->ASpeed = a->ASpeed;
	b->Damage = a->Damage;
	b->Step = a->Step;
	b->Angle = a->Angle;
	b->Angular = a->Angular;
	b->CollDetection = a->CollDetection;
	b->DeadState = a->DeadState;
	b->Flash = a->Flash;
	b->Flip = a->Flip;
	for (int i = 0; i < 16; i++)
		b->Misc[i] = a->Misc[i];
	return b;
}

lweapon EWeaponToLWeapon(lweapon b, eweapon a) { return EWeaponToLWeapon(a,b);}
eweapon LWeaponToEWeapon(eweapon b, lweapon a) { return LWeaponToEWeapon(a,b);}
lweapon EToLWeapon(lweapon b, eweapon a) { return EWeaponToLWeapon(a,b);}
eweapon LtoEWeapon(eweapon b, lweapon a) { return LWeaponToEWeapon(a,b);}

lweapon EToLWeapon(eweapon a, lweapon b) { return EWeaponToLWeapon(a,b);}
eweapon LtoEWeapon(lweapon a, eweapon b) { return LWeaponToEWeapon(a,b);}


eweapon LtoEWeapon(lweapon a){return LtoEWeapon(a);}
lweapon EtoLWeapon(eweapon a){return EtoLWeapon(a);}

//Copy the attributes of a given eweapon to a new lweapon.
//Returns -1 on error, including if the type (weap->ID) conversion is illegal.
lweapon EWeaponToLWeapon(eweapon a){
	int type = EWeaponToLWeaponID(a->ID);
	//if ( type == -1 ) return type;
	lweapon b = Screen->CreateLWeapon(type);
	b->X = a->X;
	b->Y = a->Y;
	b->Z = a->Z;
	b->Jump = a->Jump;
	b->Extend = a->Extend;
	b->TileWidth = a->TileWidth;
	b->TileHeight = a->TileHeight;
	b->HitWidth = a->HitWidth;
	b->HitHeight = a->HitHeight;
	b->HitZHeight = a->HitZHeight;
	b->HitXOffset = a->HitXOffset;
	b->HitYOffset = a->HitYOffset;
	b->DrawXOffset = a->DrawXOffset;
	b->DrawYOffset = a->DrawYOffset;
	b->DrawZOffset = a->DrawZOffset;
	b->Tile = a->Tile;
	b->CSet = a->CSet;
	b->DrawStyle = a->DrawStyle;
	b->Dir = a->Dir;
	b->OriginalTile = a->OriginalTile;
	b->OriginalCSet = a->OriginalCSet;
	b->FlashCSet = a->FlashCSet;
	b->NumFrames = a->NumFrames;
	b->Frame = a->Frame;
	b->ASpeed = a->ASpeed;
	b->Damage = a->Damage;
	b->Step = a->Step;
	b->Angle = a->Angle;
	b->Angular = a->Angular;
	b->CollDetection = a->CollDetection;
	b->DeadState = a->DeadState;
	b->Flash = a->Flash;
	b->Flip = a->Flip;
	for (int i = 0; i < 16; i++)
		b->Misc[i] = a->Misc[i];
	return b;
}


//Copy the attributes of a given eweapon to an lweapon.
//Returns -1 on error, including if the type (weap->ID) conversion is illegal.
lweapon EWeaponToLWeapon(eweapon a, lweapon b){
	int type = EWeaponToLWeaponID(a->ID);
	//if ( type == -1 ) return type;
	b->ID = type;
	b->X = a->X;
	b->Y = a->Y;
	b->Z = a->Z;
	b->Jump = a->Jump;
	b->Extend = a->Extend;
	b->TileWidth = a->TileWidth;
	b->TileHeight = a->TileHeight;
	b->HitWidth = a->HitWidth;
	b->HitHeight = a->HitHeight;
	b->HitZHeight = a->HitZHeight;
	b->HitXOffset = a->HitXOffset;
	b->HitYOffset = a->HitYOffset;
	b->DrawXOffset = a->DrawXOffset;
	b->DrawYOffset = a->DrawYOffset;
	b->DrawZOffset = a->DrawZOffset;
	b->Tile = a->Tile;
	b->CSet = a->CSet;
	b->DrawStyle = a->DrawStyle;
	b->Dir = a->Dir;
	b->OriginalTile = a->OriginalTile;
	b->OriginalCSet = a->OriginalCSet;
	b->FlashCSet = a->FlashCSet;
	b->NumFrames = a->NumFrames;
	b->Frame = a->Frame;
	b->ASpeed = a->ASpeed;
	b->Damage = a->Damage;
	b->Step = a->Step;
	b->Angle = a->Angle;
	b->Angular = a->Angular;
	b->CollDetection = a->CollDetection;
	b->DeadState = a->DeadState;
	b->Flash = a->Flash;
	b->Flip = a->Flip;
	for (int i = 0; i < 16; i++)
		b->Misc[i] = a->Misc[i];
	return b;
}


int EtoLWeaponID(int type){
	return EWeaponToLWeaponID(type);
}

int LtoEWeaponID(int type){
	return LWeaponToEWeaponID(type);
}
	
	
//Returns the centre of a given hitbox.
int CenterHitX(){}
int CenterHitY(){}
	
	

//Xor comparison of two calculations. ( e.g. Xor(n-x, n+y) ) 
//Returns true if they do not match. 
bool Xor(float calcA, float calcB){
	if ( calcA != calcB ) return true;
	return false;
}


//Randomly return true or false. 
int Chance(){
	return Rand(0,1);
}

//Randomly returns true, or false, using input 'percentChance' to determine the percentage change of a 'true return'
bool Chance(int percentChance){
	return RandB(percentChance);
}

int ProximityX(ffc a, ffc b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}


int ProximityX(ffc a, lweapon b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}


int ProximityX(ffc a, eweapon b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}
	

int ProximityX(ffc a, npc b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}


int ProximityX(ffc a, item b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}


int ProximityX(lweapon a, ffc b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(lweapon a, lweapon b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(lweapon a, eweapon b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(lweapon a, npc b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(lweapon a, item b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(eweapon a, ffc b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(eweapon a, lweapon b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(eweapon a, eweapon b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(eweapon a, npc b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(eweapon a, item b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(npc a, ffc b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(npc a, lweapon b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(npc a, eweapon b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(npc a, npc b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(npc a, item b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}


int ProximityX(item a, ffc b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(item a, lweapon b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(item a, eweapon b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(item a, npc b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(item a, item b) {
	if ( a->X > b->X ) return a->X - b->X;
	else return b->X - a->X;
}

int ProximityX(int b, ffc a) {
	if ( a->X > ComboX(b) ) return a->X - ComboX(b);
	else return ComboX(b) - a->X;
}


int ProximityX(int b, lweapon a) {
	if ( a->X > ComboX(b) ) return a->X - ComboX(b);
	else return ComboX(b) - a->X;
}


int ProximityX(int b, eweapon a) {
	if ( a->X > ComboX(b) ) return a->X - ComboX(b);
	else return ComboX(b) - a->X;
}
	

int ProximityX(int b, npc a) {
	if ( a->X > ComboX(b) ) return a->X - ComboX(b);
	else return ComboX(b) - a->X;
}


int ProximityX(int b, item a) {
	if ( a->X > ComboX(b) ) return a->X - ComboX(b);
	else return ComboX(b) - a->X;
}

int ProximityX(ffc a, int b) {
	if ( a->X > ComboX(b) ) return a->X - ComboX(b);
	else return ComboX(b) - a->X;
}


int ProximityX(lweapon a, int b) {
	if ( a->X > ComboX(b) ) return a->X - ComboX(b);
	else return ComboX(b) - a->X;
}


int ProximityX(eweapon a, int b) {
	if ( a->X > ComboX(b) ) return a->X - ComboX(b);
	else return ComboX(b) - a->X;
}
	

int ProximityX(npc a, int b) {
	if ( a->X > ComboX(b) ) return a->X - ComboX(b);
	else return ComboX(b) - a->X;
}


int ProximityX(item a, int b) {
	if ( a->X > ComboX(b) ) return a->X - ComboX(b);
	else return ComboX(b) - a->X;
}

int ProximityX(int b, int a) {
	if ( ComboX(a) > ComboX(b) ) return ComboX(a) - ComboX(b);
	else return ComboX(b) - ComboX(a);
}

int ProximityX(ffc a) {
	if ( a->X > Link->X ) return a->X - Link->X;
	else return Link->X - a->X;
}

int ProximityX(lweapon a) {
	if ( a->X > Link->X ) return a->X - Link->X;
	else return Link->X - a->X;
}

int ProximityX(eweapon a) {
	if ( a->X > Link->X ) return a->X - Link->X;
	else return Link->X - a->X;
}

int ProximityX(npc a) {
	if ( a->X > Link->X ) return a->X - Link->X;
	else return Link->X - a->X;
}

int ProximityX(item a) {
	if ( a->X > Link->X ) return a->X - Link->X;
	else return Link->X - a->X;
}

int ProximityX(int a) {
	int ax = ComboX(a);
	if ( ax > Link->X ) return ax - Link->X;
	else return Link->X - ax;
}

int ProximityY(ffc a, ffc b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}


int ProximityY(ffc a, lweapon b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}


int ProximityY(ffc a, eweapon b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}
	

int ProximityY(ffc a, npc b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}


int ProximityY(ffc a, item b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}


int ProximityY(lweapon a, ffc b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(lweapon a, lweapon b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(lweapon a, eweapon b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(lweapon a, npc b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(lweapon a, item b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(eweapon a, ffc b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(eweapon a, lweapon b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(eweapon a, eweapon b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(eweapon a, npc b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(eweapon a, item b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(npc a, ffc b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(npc a, lweapon b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(npc a, eweapon b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(npc a, npc b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(npc a, item b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}


int ProximityY(item a, ffc b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(item a, lweapon b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(item a, eweapon b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(item a, npc b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(item a, item b) {
	if ( a->Y > b->Y ) return a->Y - b->Y;
	else return b->Y - a->Y;
}

int ProximityY(int b, ffc a) {
	if ( a->Y > ComboY(b) ) return a->Y - ComboY(b);
	else return ComboY(b) - a->Y;
}


int ProximityY(int b, lweapon a) {
	if ( a->Y > ComboY(b) ) return a->Y - ComboY(b);
	else return ComboY(b) - a->Y;
}


int ProximityY(int b, eweapon a) {
	if ( a->Y > ComboY(b) ) return a->Y - ComboY(b);
	else return ComboY(b) - a->Y;
}
	

int ProximityY(int b, npc a) {
	if ( a->Y > ComboY(b) ) return a->Y - ComboY(b);
	else return ComboY(b) - a->Y;
}


int ProximityY(int a, item b) {
	if ( b->Y > ComboY(a) ) return b->Y - ComboY(a);
	else return ComboY(a) - b->Y;
}

int ProximityY(ffc a, int b) {
	if ( a->Y > ComboY(b) ) return a->Y - ComboY(b);
	else return ComboY(b) - a->Y;
}


int ProximityY(lweapon a, int b) {
	if ( a->Y > ComboY(b) ) return a->Y - ComboY(b);
	else return ComboY(b) - a->Y;
}


int ProximityY(eweapon a, int b) {
	if ( a->Y > ComboY(b) ) return a->Y - ComboY(b);
	else return ComboY(b) - a->Y;
}
	

int ProximityY(npc a, int b) {
	if ( a->Y > ComboY(b) ) return a->Y - ComboY(b);
	else return ComboY(b) - a->Y;
}


int ProximityY(item a, int b) {
	if ( a->Y > ComboY(b) ) return a->Y - ComboY(b);
	else return ComboY(b) - a->Y;
}

int ProximityY(int b, int a) {
	if ( ComboY(a) > ComboY(b) ) return ComboY(a) - ComboY(b);
	else return ComboY(b) - ComboY(a);
}

int ProximityY(ffc a) {
	if ( a->Y > Link->Y ) return a->Y - Link->Y;
	else return Link->Y - a->Y;
}

int ProximityY(lweapon a) {
	if ( a->Y > Link->Y ) return a->Y - Link->Y;
	else return Link->Y - a->Y;
}

int ProximityY(eweapon a) {
	if ( a->Y > Link->Y ) return a->Y - Link->Y;
	else return Link->Y - a->Y;
}

int ProximityY(npc a) {
	if ( a->Y > Link->Y ) return a->Y - Link->Y;
	else return Link->Y - a->Y;
}

int ProximityY(item a) {
	if ( a->Y > Link->Y ) return a->Y - Link->Y;
	else return Link->Y - a->Y;
}

int ProximityY(int a) {
	int ay = ComboY(a);
	if ( ay > Link->Y ) return ay - Link->Y;
	else return Link->Y - ay;
}

//ProximityX also needs a precise variation. 

//Proximity from centre of object's hitbox:
int ProximityX(ffc a, ffc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a);
		int bx = CenterX(b);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

//Rid these of varible declaration inefficiency?
int ProximityX(ffc a, lweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}


int ProximityX(ffc a, eweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}
	

int ProximityX(ffc a, npc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}


int ProximityX(ffc a, item b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}


int ProximityX(lweapon a, ffc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(lweapon a, lweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(lweapon a, eweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(lweapon a, npc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(lweapon a, item b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(eweapon a, ffc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(eweapon a, lweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(eweapon a, eweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(eweapon a, npc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(eweapon a, item b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(npc a, ffc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(npc a, lweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(npc a, eweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(npc a, npc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(npc a, item b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(item a, ffc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}
int ProximityX(item a, lweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(item a, eweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(item a, npc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(item a, item b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterX(a,true);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}



//Are multiple function calls less efficient than setting these once as local vars?
//int ProximityX(ffc a) {
//	if ( CenterX(a) > CenterLinkX() ) return CenterX(a) - CenterLinkX();
//	else return CenterLinkX() - CenterX(a);
//}




int ProximityY(ffc a, ffc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a);
		int bx = CenterY(b);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}


int ProximityY(ffc a, lweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}


int ProximityY(ffc a, eweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}
	

int ProximityY(ffc a, npc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(ffc a, item b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}


int ProximityY(lweapon a, ffc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(lweapon a, lweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(lweapon a, eweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(lweapon a, npc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(lweapon a, item b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(eweapon a, ffc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(eweapon a, lweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(eweapon a, eweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(eweapon a, npc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(eweapon a, item b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(npc a, ffc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}
int ProximityY(npc a, lweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(npc a, eweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(npc a, npc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}
int ProximityY(npc a, item b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}


int ProximityY(item a, ffc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(item a, lweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(item a, eweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(item a, npc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityY(item a, item b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterY(a,true);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( a->X > b->X ) return a->X - b->X;
		else return b->X - a->X;
	}
}

int ProximityX(ffc a, bool fromcentre) {
	int ax = CenterX(a);
	int lx = CenterLinkX();
	if ( fromcentre ) {
		if ( ax > lx ) return ax - lx;
		else return lx - ax;
	}
	else {
		if ( a->X > lx ) return a->X - lx;
		else return lx - a->X;
	}
}

int ProximityX(lweapon a, bool fromcentre) {
	int ax = CenterX(a);
	int lx = CenterLinkX();
	if ( fromcentre ) {
		if ( ax > lx ) return ax - lx;
		else return lx - ax;
	}
	else {
		if ( a->X > lx ) return a->X - lx;
		else return lx - a->X;
	}
}


int ProximityX(eweapon a, bool fromcentre) {
	int ax = CenterX(a);
	int lx = CenterLinkX();
	if ( fromcentre ) {
		if ( ax > lx ) return ax - lx;
		else return lx - ax;
	}
	else {
		if ( a->X > lx ) return a->X - lx;
		else return lx - a->X;
	}
}


int ProximityX(npc a, bool fromcentre) {
	int ax = CenterX(a);
	int lx = CenterLinkX();
	if ( fromcentre ) {
		if ( ax > lx ) return ax - lx;
		else return lx - ax;
	}
	else {
		if ( a->X > lx ) return a->X - lx;
		else return lx - a->X;
	}
}


int ProximityX(item a, bool fromcentre) {
	int ax = CenterX(a);
	int lx = CenterLinkX();
	if ( fromcentre ) {
		if ( ax > lx ) return ax - lx;
		else return lx - ax;
	}
	else {
		if ( a->X > lx ) return a->X - lx;
		else return lx - a->X;
	}
}



int ProximityY(ffc a, bool fromcentre) {
	int ay = CenterY(a);
	int ly = CenterLinkY();
	if ( fromcentre ) {
		if ( ay > ly ) return ay - ly;
		else return ly - ay;
	}
	else { 
		if ( a->Y > ly ) return a->Y - ly;
		else return a->Y - ly;
	}
}

int ProximityY(lweapon a, bool fromcentre) {
	int ay = CenterY(a);
	int ly = CenterLinkY();
	if ( fromcentre ) {
		if ( ay > ly ) return ay - ly;
		else return ly - ay;
	}
	else { 
		if ( a->Y > ly ) return a->Y - ly;
		else return a->Y - ly;
	}
}


int ProximityY(eweapon a, bool fromcentre) {
	int ay = CenterY(a);
	int ly = CenterLinkY();
	if ( fromcentre ) {
		if ( ay > ly ) return ay - ly;
		else return ly - ay;
	}
	else { 
		if ( a->Y > ly ) return a->Y - ly;
		else return a->Y - ly;
	}
}


int ProximityY(npc a, bool fromcentre) {
	int ay = CenterY(a);
	int ly = CenterLinkY();
	if ( fromcentre ) {
		if ( ay > ly ) return ay - ly;
		else return ly - ay;
	}
	else { 
		if ( a->Y > ly ) return a->Y - ly;
		else return a->Y - ly;
	}
}


int ProximityY(item a, bool fromcentre) {
	int ay = CenterY(a);
	int ly = CenterLinkY();
	if ( fromcentre ) {
		if ( ay > ly ) return ay - ly;
		else return ly - ay;
	}
	else { 
		if ( a->Y > ly ) return a->Y - ly;
		else return a->Y - ly;
	}
}



///Proximity between *ptr and combo. 

int ProximityX(int a, ffc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboX(a);
		int bx = CenterX(b);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboX(a) > b->X ) return ComboX(a) - b->X;
		else return b->X - ComboX(a);
	}
}

int ProximityX(int a, lweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboX(a);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboX(a) > b->X ) return ComboX(a) - b->X;
		else return b->X - ComboX(a);
	}
}

int ProximityX(int a, eweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboX(a);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboX(a) > b->X ) return ComboX(a) - b->X;
		else return b->X - ComboX(a);
	}
}

int ProximityX(int a, npc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboX(a);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboX(a) > b->X ) return ComboX(a) - b->X;
		else return b->X - ComboX(a);
	}
}

int ProximityX(int a, item b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboX(a);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboX(a) > b->X ) return ComboX(a) - b->X;
		else return b->X - ComboX(a);
	}
}

int ProximityX(ffc b, int a, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboX(a);
		int bx = CenterX(b);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboX(a) > b->X ) return ComboX(a) - b->X;
		else return b->X - ComboX(a);
	}
}

int ProximityX(lweapon b, int a, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboX(a);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboX(a) > b->X ) return ComboX(a) - b->X;
		else return b->X - ComboX(a);
	}
}

int ProximityX(eweapon b, int a, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboX(a);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboX(a) > b->X ) return ComboX(a) - b->X;
		else return b->X - ComboX(a);
	}
}

int ProximityX(npc b, int a, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboX(a);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboX(a) > b->X ) return ComboX(a) - b->X;
		else return b->X - ComboX(a);
	}
}

int ProximityX(item b, int a, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboX(a);
		int bx = CenterX(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboX(a) > b->X ) return ComboX(a) - b->X;
		else return b->X - ComboX(a);
	}
}

int ProximityX(int b, int a, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboX(a);
		int bx = CenterComboX(b);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboX(a) > ComboX(b) ) return ComboX(a) - ComboX(b);
		else return ComboX(b) - ComboX(a);
	}
}

int ProximityY(int a, ffc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboY(a);
		int bx = CenterY(b);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboY(a) > b->Y ) return ComboY(a) - b->Y;
		else return b->Y - ComboY(a);
	}
}

int ProximityY(int a, lweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboY(a);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboY(a) > b->Y ) return ComboY(a) - b->Y;
		else return b->Y - ComboY(a);
	}
}

int ProximityY(int a, eweapon b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboY(a);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboY(a) > b->Y ) return ComboY(a) - b->Y;
		else return b->Y - ComboY(a);
	}
}

int ProximityY(int a, npc b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboY(a);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboY(a) > b->Y ) return ComboY(a) - b->Y;
		else return b->Y - ComboY(a);
	}
}

int ProximityY(int a, item b, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboY(a);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboY(a) > b->Y ) return ComboY(a) - b->Y;
		else return b->Y - ComboY(a);
	}
}

int ProximityY(ffc b, int a, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboY(a);
		int bx = CenterY(b);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboY(a) > b->Y ) return ComboY(a) - b->Y;
		else return b->Y - ComboY(a);
	}
}

int ProximityY(lweapon b, int a, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboY(a);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboY(a) > b->Y ) return ComboY(a) - b->Y;
		else return b->Y - ComboY(a);
	}
}

int ProximityY(eweapon b, int a, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboY(a);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboY(a) > b->Y ) return ComboY(a) - b->Y;
		else return b->Y - ComboY(a);
	}
}

int ProximityY(npc b, int a, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboY(a);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboY(a) > b->Y ) return ComboY(a) - b->Y;
		else return b->Y - ComboY(a);
	}
}

int ProximityY(item b, int a, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboY(a);
		int bx = CenterY(b,true);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboY(a) > b->Y ) return ComboY(a) - b->Y;
		else return b->Y - ComboY(a);
	}
}


int ProximityY(int b, int a, bool fromcentre ) {
	if ( fromcentre ) {
		int ax = CenterComboY(a);
		int bx = CenterComboY(b);
		if ( ax > bx ) return ax - bx;
		else return bx - ax;
	}
	else {
		if ( ComboY(a) > ComboY(b) ) return ComboY(a) - ComboY(b);
		else return ComboY(b) - ComboY(a);
	}
}


//! Need Proximity X/Y between pointers and combos without centre option, and combo / Link Proximity

int CenterProximityX(ffc a, ffc b) { }

int PreciseCenterX(ffc f) {}
	//Find the precise centre of an ffc using its hitboxes. 
	//CenterFX and CenterFY ?
	//Thing that Alucard wants. 	
	
int RelativeProximityX(ffc a, ffc b) {}
	//If I lose some more sanity, make a version of Proximity*() that returns a relative value. 

	//!Z Unfinished Pixel Collision Functions
	
//int PixelCollision(ffc a, int pixel, int height, int width, ffc b, int pixel, int height, int width) {} 

	
	int PixelCollision(ffc a, int pixelA, ffc b, int pixelB) {} 
	//Return if two specific pixels occupy the same coordinates
	//We should automate reading the object size based on its properties, such as its TileHeight, or Extend value,
	//...but how do we want to define 'pixel' for objects larger than one tile?
	//...with one tile, it's 00 to FF, which is super-easy; but ... I suppose 0000 to FFFF? 
	//...thus, up to four tiles in each dir, with the third/fourth digits representing the tile, and the first/second the pixel of that tile?
	//Even thus, do we want to include a *range* for each object?
	

int DistanceX(ffc a, ffc b) {}
//As Proximity, but returns the difference between the pointers as a signed value, instead of an absolute. 
	



//Returns the VISIBLE centre of lweapon (sprite/tiles), with option to include its HitYOffset
//int VisCenterY(lweapon anLWeapon, bool trueoffset) {
//	if ( trueoffset ) return anLWeapon->Y+HitHeight/2 + anLWeapon->HitYOffset;
//	else return return anLWeapon->Y+HitHeight/2;
//}

//Returns the VISIBLE centre of eweapon (sprite/tiles), with option to include its HitXOffset
//int VisCenterX(eweapon anEWeapon, bool trueoffset) { 
//	if ( trueoffset ) return anEWeapon->X+HitWidth/2 + anEWeapon->HitXOffset;
//	else return return anEWeapon->X+HitWidth/2;
//}

//Returns the VISIBLE centre of eweapon (sprite/tiles), with option to include its HitYOffset
//int VisCenterY(eweapon anEWeapon, bool trueoffset) {
//	if ( trueoffset ) return anEWeapon->Y+HitHeight/2 + anEWeapon->HitYOffset;
//	else return return anLWeapon->Y+HitHeight/2;
//}

//Returns the VISIBLE centre of npc (sprite/tiles), with option to include its HitXOffset
//int VisCenterX(npc n, bool trueoffset) { 
//	if ( trueoffset ) return n->X+HitWidth/2 + n->HitXOffset;
//	else return return n->X+HitWidth/2;
//}

//Returns the VISIBLE centre of npc (sprite/tiles), with option to include its HitYOffset
//int VisCenterY(npc n, bool trueoffset) {
//	if ( trueoffset ) return n->Y+HitHeight/2 + n->HitYOffset;
//	else return return n->Y+HitHeight/2;
//}

//Returns the VISIBLE centre of npc (sprite/tiles), with option to include its HitXOffset
//int VisCenterX(item i, bool trueoffset) { 
//	if ( trueoffset ) return i->X+HitWidth/2 + i->HitXOffset;
//	else return return i->X+HitWidth/2;
//}


//! Functions to read all screen flag and enemy flag types

//! Typecasting

//Convert boolean variable 'input' to floating point, or int.
float BoolToFloat(bool input){
	if ( input ) return 1;
	else return 0;
}

int BoolToInt(bool input) {
	BoolToFloat(input);
}

//! Collision with hitbox constraints. 
//Check for collision between ffc 'f' and a combo at location 'cmb'. 
bool Collision(int cmb, ffc f, int a1, int b1, int c1, int d1, int a2, int b2, int c2, int d2){
	int c[8];
	c[0] = ComboX(cmb);
	c[1] = ComboY(cmb);
	c[2] = ComboX(cmb)+16;
	c[3] = ComboY(cmb)+16;
	c[4] = (f->X);
	c[5] = (f->Y);
	c[6] = c[4]+(f->EffectWidth);
	c[7] = c[5]+(f->EffectHeight);
	return RectCollision( c[0]+a1, c[1]+b1, c[2]+c1, c[3]+d1, c[4]+a2, c[5]+b2, c[6]+c2, c[7]+d2 );
}


//Check for collision between lweapon 'l' and a combo at location 'cmb'. 
bool Collision(int cmb, lweapon l, int a1, int b1, int c1, int d1, int a2, int b2, int c2, int d2){
	int c[8];
	c[0] = ComboX(cmb);
	c[1] = ComboY(cmb);
	c[2] = ComboX(cmb)+16;
	c[3] = ComboY(cmb)+16;
	c[4] = (l->X)+l->HitXOffset+l->DrawXOffset;
	c[5] = (l->Y)+l->HitYOffset+l->DrawYOffset;
	c[6] = c[4]+l->HitWidth;
	c[7] = c[5]+l->HitHeight;
	return RectCollision( c[0]+a1, c[1]+b1, c[2]+c1, c[3]+d1, c[4]+a2, c[5]+b2, c[6]+c2, c[7]+d2 );
}

//Check for collision between eweapon 'e' and a combo at location 'cmb'. 
bool Collision(int cmb, eweapon e,  int a1, int b1, int c1, int d1, int a2, int b2, int c2, int d2){
	int c[8];
	c[0] = ComboX(cmb);
	c[1] = ComboY(cmb);
	c[2] = ComboX(cmb)+16;
	c[3] = ComboY(cmb)+16;
	c[4] = (e->X)+e->HitXOffset+e->DrawXOffset;
	c[5] = (e->Y)+e->HitYOffset+e->DrawYOffset;
	c[5] = c[4]+e->HitWidth;
	c[7] = c[5]+e->HitHeight;
	return RectCollision( c[0]+a1, c[1]+b1, c[2]+c1, c[3]+d1, c[4]+a2, c[5]+b2, c[6]+c2, c[7]+d2 );
}

//Check for collision between npc 'n' and a combo at location 'cmb'. 
bool Collision(int cmb, npc n,  int a1, int b1, int c1, int d1, int a2, int b2, int c2, int d2){
	int c[8];
	c[0] = ComboX(cmb);
	c[1] = ComboY(cmb);
	c[2] = ComboX(cmb)+16;
	c[3] = ComboY(cmb)+16;
	c[4] = (n->X)+n->HitXOffset+n->DrawXOffset;
	c[5] = (n->Y)+n->HitYOffset+n->DrawYOffset;
	c[6] = c[4]+n->HitWidth;
	c[7] = c[5]+n->HitHeight;
	return RectCollision( c[0]+a1, c[1]+b1, c[2]+c1, c[3]+d1, c[4]+a2, c[5]+b2, c[6]+c2, c[7]+d2 );
}

//Check for collision between item 'i' and a combo at location 'cmb'. 
bool Collision(int cmb, item i,  int a1, int b1, int c1, int d1, int a2, int b2, int c2, int d2){
	int c[8];
	c[0] = ComboX(cmb);
	c[1] = ComboY(cmb);
	c[2] = ComboX(cmb)+16;
	c[3] = ComboY(cmb)+16;
	c[4] = (i->X)+i->HitXOffset+i->DrawXOffset;
	c[5] = (i->Y)+i->HitYOffset+i->DrawYOffset;
	c[6] = c[4]+i->HitWidth;
	c[7] = c[5]+i->HitHeight;
	return RectCollision( c[0]+a1, c[1]+b1, c[2]+c1, c[3]+d1, c[4]+a2, c[5]+b2, c[6]+c2, c[7]+d2 );
}


//Check for collision between Link and a combo at location 'cmb'. 
bool Collision(int cmb,  int a1, int b1, int c1, int d1, int a2, int b2, int c2, int d2){
	int c[8];
	c[0] = ComboX(cmb);
	c[1] = ComboY(cmb);
	c[2] = ComboX(cmb)+16;
	c[3] = ComboY(cmb)+16;
	c[4] = Link->X+Link->HitXOffset+Link->DrawXOffset;
	c[5] = Link->Y+Link->HitYOffset+Link->DrawYOffset;
	c[6] = c[0]+(Link->HitWidth);
	c[7] = c[1]+(Link->HitHeight);
	return RectCollision( c[0]+a1, c[1]+b1, c[2]+c1, c[3]+d1, c[4]+a2, c[5]+b2, c[6]+c2, c[7]+d2 );
}




//Returns collision between an lweapon and a combo, only if its direction is 'dir'.
//Set checkcoldetection true if you wish weapons without collision to automatically return false.
bool CollisionDir(int cmb, lweapon l, int dir, bool checkcoldetection) {
	int c[8];
	c[0] = ComboX(cmb);
	c[1] = ComboY(cmb);
	c[2] = ComboX(cmb)+16;
	c[3] = ComboY(cmb)+16;
	c[4] = (l->X)+l->HitXOffset+l->DrawXOffset;
	c[5] = (l->Y)+l->HitYOffset+l->DrawYOffset;
	c[6] = c[4]+l->HitWidth;
	c[7] = c[5]+l->HitHeight;
	if ( checkcoldetection && !l->CollDetection ) return false;
	if ( l->Dir != dir ) return false;
	return RectCollision( c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7] );
}

//Returns collision between an lweapon and a combo.
//Returns false base don direction:
//Set 'facingspecificdir' to true, to check only if a weapon is facing a specific direction.
//Set it false, if you want to check if a weapon is NOT facing a specific direction. 
//Set checkcoldetection true if you wish weapons without collision to automatically return false.
bool CollisionDir(int cmb, lweapon l, int dir, bool facingspecificdir, bool checkcoldetection) {
	int c[8];
	c[0] = ComboX(cmb);
	c[1] = ComboY(cmb);
	c[2] = ComboX(cmb)+16;
	c[3] = ComboY(cmb)+16;
	c[4] = (l->X)+l->HitXOffset+l->DrawXOffset;
	c[5] = (l->Y)+l->HitYOffset+l->DrawYOffset;
	c[6] = c[4]+l->HitWidth;
	c[7] = c[5]+l->HitHeight;
	if ( checkcoldetection && !l->CollDetection ) return false;
	if ( facingspecificdir && l->Dir != dir ) return false;
	if ( !facingspecificdir && l->Dir == dir ) return false;
	return RectCollision( c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7] );
}

//Feb 2016
bool Pos(int val){ return ( val > 0 ); }
bool Neg(int val){ return ( val < 0 ); }


//Returns if arg valA is less than all other values passed. Overloaded to work with two, to eight values.
int Min(int valA, int valB, int valC){
	int val = 214747.9999;
	int arr[]={valA, valB, valC};
	for ( int q = 0; q < SizeOfArray(arr); q++ ) {
		if ( arr[q] < val ) val = arr[q];
	}
	return val;
}


int Min(int valA, int valB, int valC, int valD){
	int val = 214747.9999;
	int arr[]={valA, valB, valC, valD};
	for ( int q = 0; q < SizeOfArray(arr); q++ ) {
		if ( arr[q] < val ) val = arr[q];
	}
	return val;
}


int Min(int valA, int valB, int valC, int valD, int valE){
	int val = 214747.9999;
	int arr[]={valA, valB, valC, valD, valE};
	for ( int q = 0; q < SizeOfArray(arr); q++ ) {
		if ( arr[q] < val ) val = arr[q];
	}
	return val;
}


int Min(int valA, int valB, int valC, int valD, int valE, int valF){
	int val = 214747.9999;
	int arr[]={valA, valB, valC, valD, valE, valF};
	for ( int q = 0; q < SizeOfArray(arr); q++ ) {
		if ( arr[q] < val ) val = arr[q];
	}
	return val;
}
int Min(int valA, int valB, int valC, int valD, int valE, int valF, int valG){
	int val = 214747.9999;
	int arr[]={valA, valB, valC, valD, valE, valF, valG};
	for ( int q = 0; q < SizeOfArray(arr); q++ ) {
		if ( arr[q] < val ) val = arr[q];
	}
	return val;
}

int Min(int valA, int valB, int valC, int valD, int valE, int valF, int valG, int valH){
	int val = 214747.9999;
	int arr[]={valA, valB, valC, valD, valE, valF, valG, valH};
	for ( int q = 0; q < SizeOfArray(arr); q++ ) {
		if ( arr[q] < val ) val = arr[q];
	}
	return val;
}

//Returns if arg valA is greater than all other values passed. Overloaded for two, to eight values.
int Max(int valA, int valB, int valC){
	int arr[]={valA, valB, valC};
	int val = -214747.9999;
	for ( int q = 0; q < SizeOfArray(arr); q++ ) {
		if ( arr[q] > val ) val = arr[q];
	}
	return val;
}

int Max(int valA, int valB, int valC, int valD){
	int arr[]={valA, valB, valC, valD};
	int val = -214747.9999;
	for ( int q = 0; q < SizeOfArray(arr); q++ ) {
		if ( arr[q] > val ) val = arr[q];
	}
	return val;
}

int Max(int valA, int valB, int valC, int valD, int valE){
	int arr[]={valA, valB, valC, valD, valE};
	int val = -214747.9999;
	for ( int q = 0; q < SizeOfArray(arr); q++ ) {
		if ( arr[q] > val ) val = arr[q];
	}
	return val;
}


int Max(int valA, int valB, int valC, int valD, int valE, int valF){
	int arr[]={valA, valB, valC, valD, valE, valF};
	int val = -214747.9999;
	for ( int q = 0; q < SizeOfArray(arr); q++ ) {
		if ( arr[q] > val ) val = arr[q];
	}
	return val;
}

int Max(int valA, int valB, int valC, int valD, int valE, int valF, int valG){
	int arr[]={valA, valB, valC, valD, valE, valF, valG};
	int val = -214747.9999;
	for ( int q = 0; q < SizeOfArray(arr); q++ ) {
		if ( arr[q] > val ) val = arr[q];
	}
	return val;
}

int Max(int valA, int valB, int valC, int valD, int valE, int valF, int valG, int valH){
	int arr[]={valA, valB, valC, valD, valE, valF, valG, valH};
	int val = -214747.9999;
	for ( int q = 0; q < SizeOfArray(arr); q++ ) {
		if ( arr[q] > val ) val = arr[q];
	}
	return val;
}

//Returns the lowest value in an array
int Min(int arr){
	int val = 214747.9999;
	for ( int q = 0; q < SizeOfArray(arr); q++ ) {
		if ( arr[q] < val ) val = arr[q];
	}
	return val;
}

//Returns the highest value in an array
int Max(int arr){
	int val = -214747.9999;
	for ( int q = 0; q < SizeOfArray(arr); q++ ) {
		if ( arr[q] > val ) val = arr[q];
	}
	return val;
}

//Returns the index holding the lowest value in an array
//If the lowest value is present in two or more indices, this will return the lowest-numbered index of the set.
int MinIndex(int arr){
	int val = 214747.9999;
	int index;
	for ( int q = 0; q < SizeOfArray(arr); q++ ) {
		if ( arr[q] < val ) { 
			val = arr[q];
			index = q;
		}
	}
	return index;
}

//Returns the index holding the highest value in an array
//If the highest value is present in two or more indices, this will return the lowest-numbered index of the set.
int MaxIndex(int arr){
	int val = -214747.9999;
	int index;
	for ( int q = 0; q < SizeOfArray(arr); q++ ) {
		if ( arr[q] > val ) {
			val = arr[q];
			index = q;
		}
	}
	return index;
}


//Creates an item ont he screen at link's 
//position, giving it to him,a nd running its pick-up script.
//itm_id is the item ID number
//if holdtype is set to a Link->Action for holding up an item
//then Link will hold the item up as desired.
void GiveLinkItem(int itm_id, int holdtype){
    item i = Screen->CreateItem(itm_id);
    i->X = Link->X;
    i->Y = Link->Y;
    i->Z = Link->Z;
    if ( holdtype == LA_HOLD1LAND || holdtype == LA_HOLD2LAND || holdtype == LA_HOLD1WATER || holdtype == LA_HOLD2WATER ) {
        Link->HeldItem = itm_id;
        Link->Action = holdtype;
    }
}

//Creates an item ont he screen at link's 
//position, giving it to him,a nd running its pick-up script.
//itm_id is the item ID number
//Link does not hold up this item.
void GiveLinkItem(int itm_id){
    GiveLinkItem(itm_id,0);
}
    
    
    
    ///March 2016
    
//Constants for AdjacentCombo()
//This now uses DIR_* constants, so you can do AdjacentCombo(cmb,Link->Dir)
//Returns the Nth combo index of a combo based on a central point, and a direction.
//For example, combo 22 + COMBO_UPRIGHT returns '7', 
//as combo 7 is to the upper-right of combo 22.
int AdjacentCombo(int cmb, int dir){
    int combooffsets[13]={-0x10, 0x10, -1, 1, -0x11, -0x0F, 0x0F, 0x11};
    if ( cmb % 16 == 0 ) combooffsets[9] = 1;
    if ( (cmb & 15) == 1 ) combooffsets[10] = 1; 
    if ( cmb < 0x10 ) combooffsets[11] = 1; //if it's the top row
    if ( cmb > 0x9F ) combooffsets[12] = 1; //if it's on the bottom row
    if ( combooffsets[9] && ( dir == CMB_LEFT || dir == CMB_UPLEFT || dir == CMB_DOWNLEFT || dir == CMB_LEFTUP ) ) return 0; //if the left columb
    if ( combooffsets[10] && ( dir == CMB_RIGHT || dir == CMB_UPRIGHT || dir == CMB_DOWNRIGHT ) ) return 0; //if the right column
    if ( combooffsets[11] && ( dir == CMB_UP || dir == CMB_UPRIGHT || dir == CMB_UPLEFT || dir == CMB_LEFTUP ) ) return 0; //if the top row
    if ( combooffsets[12] && ( dir == CMB_DOWN || dir == CMB_DOWNRIGHT || dir == CMB_DOWNLEFT ) ) return 0; //if the bottom row
    else if ( cmb >= 0 && cmb <= 176 ) return cmb + combooffsets[dir];
    else return -1;
}   
        

    ///March 2016
    
//Constants for AdjacentCombo()
//This now uses DIR_* constants, so you can do AdjacentCombo(cmb,Link->Dir)
//Returns the Nth combo index of a combo based on a central point, and a direction.
//For example, combo 22 + COMBO_UPRIGHT returns '7', 
//as combo 7 is to the upper-right of combo 22.
//dist is the number of combos away from cmb

//! rETURNS THE COMBO id OF A COMBO BASED ON A LOCATION, IN A GIVEM DIRECTION, n COMBOS AWAY.
int AdjacentCombo(int cmb, int dir, int dist){
    int combooffsets[13]={-0x10, 0x10, -1, 1, -0x11, -0x0F, 0x0F, 0x11};
    if ( cmb % 16 == 0 ) combooffsets[9] = 1;
    if ( (cmb & 15) == 1 ) combooffsets[10] = 1; 
    if ( cmb < 0x10 ) combooffsets[11] = 1; //if it's the top row
    if ( cmb > 0x9F ) combooffsets[12] = 1; //if it's on the bottom row
    if ( combooffsets[9] && ( dir == DIR_LEFT || dir == DIR_LEFTUP || dir == DIR_LEFTDOWN || dir == DIR_LEFTUP ) ) {
	    return 0; //if the left columb
    }
    if ( combooffsets[10] && ( dir == DIR_RIGHT || dir == DIR_RIGHTUP || dir == DIR_RIGHTDOWN ) ) {
	    return 0; //if the left columb
    }
    if ( combooffsets[11] && ( dir == DIR_UP || dir == DIR_RIGHTUP || dir == DIR_LEFTUP || dir == DIR_LEFTUP ) ) {
	    return 0; //if the left columb
    }
    if ( combooffsets[12] && ( dir == DIR_DOWN || dir == DIR_RIGHTDOWN || dir == DIR_LEFTDOWN ) ) {
	    return 0; //if the left columb
    }
    int cmbs[2];//needs a for loop to ensure that t returns the most valid combo
	    
    if ( cmb >= 0 && cmb < 176 ) {
		cmbs[0] = cmb;
		for ( cmbs[1] = 0; cmbs[1] < dist; cmbs[1]++ ) {
			if ( dir == DIR_LEFT && ComboX(cmbs[0]) == 0 ) return cmbs[0];
			if ( dir == DIR_RIGHT && ComboX(cmbs[0]) == 240 ) return cmbs[0];
			if ( dir == DIR_UP && ComboY(cmbs[0]) == 0 ) return cmbs[0];
			if ( dir == DIR_DOWN && ComboY(cmbs[0]) == 160 ) return cmbs[0];
			cmbs[0] += (combooffsets[dir]);
			if ( cmbs[0] < 0 || cmbs[0] > 175 ) return cmbs[0];
			if ( cmb % 16 == 0 ) combooffsets[9] = 1;
			if ( (cmb & 15) == 1 ) combooffsets[10] = 1; 
			if ( cmb < 0x10 ) combooffsets[11] = 1; //if it's the top row
			if ( cmb > 0x9F ) combooffsets[12] = 1; //if it's on the bottom row
			if ( combooffsets[9] && ( dir == DIR_LEFT || dir == DIR_LEFTUP || dir == DIR_LEFTDOWN || dir == DIR_LEFTUP ) ) return cmbs[0]; //if the left columb
			if ( combooffsets[10] && ( dir == DIR_RIGHT || dir == DIR_RIGHTUP || dir == DIR_RIGHTDOWN ) ) return cmbs[0]; //if the right column
			if ( combooffsets[11] && ( dir == DIR_UP || dir == DIR_RIGHTUP || dir == DIR_LEFTUP || dir == DIR_LEFTUP ) ) return cmbs[0]; //if the top row
			if ( combooffsets[12] && ( dir == DIR_DOWN || dir == DIR_RIGHTDOWN || dir == DIR_LEFTDOWN ) ) return cmbs[0]; //if the bottom row
		}
		return cmbs[0];
	}
    else return -1;
}  

//Returns if two pointers are within a proximity of 'distance' in pixels.
//Link and an object (X-Axis)
bool DistX(int a, int distance) {
    int dist;
	if ( ComboX(a) > Link->X ) dist = ComboX(a) - Link->X;
	else dist = Link->X - ComboX(a);
    return ( dist <= distance );
} 
bool DistX(ffc a, int distance) {
    int dist;
    if ( a->X > Link->X ) dist = a->X - Link->X;
	else dist = Link->X - a->X;
    return ( dist <= distance );
} //Link to ffc distance
bool DistX(lweapon a, int distance) {
    int dist;
    if ( a->X > Link->X ) dist = a->X - Link->X;
	else dist = Link->X - a->X;
    return ( dist <= distance );
}
bool DistX(eweapon a, int distance) {
    int dist;
    if ( a->X > Link->X ) dist = a->X - Link->X;
	else dist = Link->X - a->X;
    return ( dist <= distance );
}
bool DistX(npc a, int distance) {
    int dist;
    if ( a->X > Link->X ) dist = a->X - Link->X;
	else dist = Link->X - a->X;
    return ( dist <= distance );
}
bool DistX(item a, int distance) {
    int dist;
    if ( a->X > Link->X ) dist = a->X - Link->X;
	else dist = Link->X - a->X;
    return ( dist <= distance );
}

//! The signature of this will clash with ProximityX(int a, int b)
//Link and an object (Y-Axis)
bool DistY(int a, int distance) {
    int dist;
	if ( ComboY(a) > Link->Y ) dist = ComboY(a) - Link->Y;
	else dist = Link->Y - ComboY(a);
    return ( dist <= distance );

}
bool DistY(ffc a, int distance) {
    int dist;
    if ( a->Y > Link->Y ) dist = a->Y - Link->Y;
	else dist = Link->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(lweapon a, int distance) {
    int dist;
    if ( a->Y > Link->Y ) dist = a->Y - Link->Y;
	else dist = Link->Y - a->Y;
    return ( dist <= distance );
}
bool DistY(eweapon a, int distance) {
    int dist;
    if ( a->Y > Link->Y ) dist = a->Y - Link->Y;
	else dist = Link->Y - a->Y;
    return ( dist <= distance );
}
bool DistY(npc a, int distance) {
    int dist;
    if ( a->Y > Link->Y ) dist = a->Y - Link->Y;
	else dist = Link->Y - a->Y;
    return ( dist <= distance );
}
bool DistY(item a, int distance) {
    int dist;
    if ( a->Y > Link->Y ) dist = a->Y - Link->Y;
	else dist = Link->Y - a->Y;
    return ( dist <= distance );
}


//Returns if two pointers are within a proximity of 'distance' in pixels.
//Two objects (X-Axis)

//X (combo)
bool DistX(int a, int b, int distance) {
	int dist;
	if ( ComboX(a) > ComboX(b) ) dist = ComboX(a) - ComboX(b);
	else dist = ComboX(b) - ComboX(a);
	return ( dist <= distance );
}
bool DistX(int a, ffc b, int distance) {
    int dist;
    if ( b->X > ComboX(a) ) dist = b->X - ComboX(a);
	else dist = ComboX(a) - b->X;
    return ( dist <= distance );
}
bool DistX(int a, lweapon b, int distance) {
    int dist;
    if ( b->X > ComboX(a) ) dist = b->X - ComboX(a);
	else dist = ComboX(a) - b->X;
    return ( dist <= distance );
} 
bool DistX(int a, eweapon b, int distance) {
    int dist;
    if ( b->X > ComboX(a) ) dist = b->X - ComboX(a);
	else dist = ComboX(a) - b->X;
    return ( dist <= distance );
} 
bool DistX(int a, npc b, int distance) {
    int dist;
    if ( b->X > ComboX(a) ) dist = b->X - ComboX(a);
	else dist = ComboX(a) - b->X;
    return ( dist <= distance );
} 
bool DistX(int a, item b, int distance) {
    int dist;
    if ( b->X > ComboX(a) ) dist = b->X - ComboX(a);
	else dist = ComboX(a) - b->X;
    return ( dist <= distance );
}

//X (ffc)
bool DistX(ffc a, int b, int distance) {
    int dist;
    if ( a->X > ComboX(b) ) dist = a->X - ComboX(b);
	else dist = ComboX(b) - a->X;
    return ( dist <= distance );
}
bool DistX(ffc a, ffc b, int distance) {
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(ffc a, lweapon b, int distance) {
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(ffc a, eweapon b, int distance) {
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(ffc a, npc b, int distance) {
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(ffc a, item b, int distance) {
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 

//X (lweapon)
bool DistX(lweapon a, int b, int distance) {
    int dist;
    if ( a->X > ComboX(b) ) dist = a->X - ComboX(b);
	else dist = ComboX(b) - a->X;
    return ( dist <= distance );
} 
bool DistX(lweapon a, ffc b, int distance) {    
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(lweapon a, lweapon b, int distance) {    
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(lweapon a, eweapon b, int distance) {    
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(lweapon a, npc b, int distance) {    
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(lweapon a, item b, int distance) {    
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 

//X (eweapon)

bool DistX(eweapon a, int b, int distance) {    
    int dist;
    if ( a->X > ComboX(b) ) dist = a->X - ComboX(b);
	else dist = ComboX(b) - a->X;
    return ( dist <= distance );
}

bool DistX(eweapon a, ffc b, int distance) {    
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(eweapon a, lweapon b, int distance) {    
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(eweapon a, eweapon b, int distance) {    
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(eweapon a, npc b, int distance) {    
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(eweapon a, item b, int distance) {    
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 

//X (npc)
bool DistX(npc a, int b, int distance) {    
    int dist;
    if ( a->X > ComboX(b) ) dist = a->X - ComboX(b);
	else dist = ComboX(b) - a->X;
    return ( dist <= distance );
}
bool DistX(npc a, ffc b, int distance) {
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(npc a, lweapon b, int distance) {
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(npc a, eweapon b, int distance) {
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(npc a, npc b, int distance) {
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(npc a, item b, int distance) {
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 

//X (item)
bool DistX(item a, int b, int distance) {
    int dist;
    if ( a->X > ComboX(b) ) dist = a->X - ComboX(b);
	else dist = ComboX(b) - a->X;
    return ( dist <= distance );
}
bool DistX(item a, ffc b, int distance) {
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(item a, lweapon b, int distance) {
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(item a, eweapon b, int distance) {
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(item a, npc b, int distance) {    
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 
bool DistX(item a, item b, int distance) {
    int dist;
    if ( a->X > b->X ) dist = a->X - b->X;
	else dist = b->X - a->X;
    return ( dist <= distance );
} 

//Two objects (Y-Axis)

//Y (combo)
bool DistY(int a, int b, int distance) {
    int dist;
	if ( ComboY(a) > ComboY(b) ) dist = ComboY(a) - ComboY(b);
	else dist = ComboY(b) - ComboY(a);
    return ( dist <= distance );
}
bool DistY(int a, ffc b, int distance) {
    int dist;
    if ( b->Y > ComboY(a) ) dist = b->Y - ComboY(a);
	else dist = ComboY(a) - b->Y;
    return ( dist <= distance );
}
bool DistY(int a, lweapon b, int distance) {
    int dist;
    if ( b->Y > ComboY(a) ) dist = b->Y - ComboY(a);
	else dist = ComboY(a) - b->Y;
    return ( dist <= distance );
} 
bool DistY(int a, eweapon b, int distance) {
    int dist;
    if ( b->Y > ComboY(a) ) dist = b->Y - ComboY(a);
	else dist = ComboY(a) - b->Y;
    return ( dist <= distance );
} 
bool DistY(int a, npc b, int distance) {
    int dist;
    if ( b->Y > ComboY(a) ) dist = b->Y - ComboY(a);
	else dist = ComboY(a) - b->Y;
    return ( dist <= distance );
} 
bool DistY(int a, item b, int distance) {
    int dist;
    if ( b->Y > ComboY(a) ) dist = b->Y - ComboY(a);
	else dist = ComboY(a) - b->Y;
    return ( dist <= distance );
}

bool DistY(ffc a, int b, int distance) {
    int dist;
    if ( a->Y > ComboY(b) ) dist = a->Y - ComboY(b);
	else dist = ComboY(b) - a->Y;
    return ( dist <= distance );
}

//Y (ffc)
bool DistY(ffc a, ffc b, int distance) {
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(ffc a, lweapon b, int distance) {
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(ffc a, eweapon b, int distance) {
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(ffc a, npc b, int distance) {
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(ffc a, item b, int distance) {
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 

//Y (lweapon)
bool DistY(lweapon a, int b, int distance) {
    int dist;
    if ( a->Y > ComboY(b) ) dist = a->Y - ComboY(b);
	else dist = ComboY(b) - a->Y;
    return ( dist <= distance );
} 
bool DistY(lweapon a, ffc b, int distance) {    
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(lweapon a, lweapon b, int distance) {    
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(lweapon a, eweapon b, int distance) {    
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(lweapon a, npc b, int distance) {    
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(lweapon a, item b, int distance) {    
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 

//Y (eweapon)
bool DistY(eweapon a, int b, int distance) {    
    int dist;
    if ( a->Y > ComboY(b) ) dist = a->Y - ComboY(b);
	else dist = ComboY(b) - a->Y;
    return ( dist <= distance );
}
bool DistY(eweapon a, ffc b, int distance) {    
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(eweapon a, lweapon b, int distance) {    
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(eweapon a, eweapon b, int distance) {    
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(eweapon a, npc b, int distance) {    
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(eweapon a, item b, int distance) {    
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 

//Y (npc)
bool DistY(npc a, int b, int distance) {    
    int dist;
    if ( a->Y > ComboY(b) ) dist = a->Y - ComboY(b);
	else dist = ComboY(b) - a->Y;
    return ( dist <= distance );
}
bool DistY(npc a, ffc b, int distance) {
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(npc a, lweapon b, int distance) {
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(npc a, eweapon b, int distance) {
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(npc a, npc b, int distance) {
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(npc a, item b, int distance) {
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 

//Y (item)
bool DistY(item a, int b, int distance) {
int dist;
    if ( a->Y > ComboY(b) ) dist = a->Y - ComboY(b);
	else dist = ComboY(b) - a->Y;
    return ( dist <= distance );
}
bool DistY(item a, ffc b, int distance) {
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(item a, lweapon b, int distance) {
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(item a, eweapon b, int distance) {
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(item a, npc b, int distance) {    
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 
bool DistY(item a, item b, int distance) {
    int dist;
    if ( a->Y > b->Y ) dist = a->Y - b->Y;
	else dist = b->Y - a->Y;
    return ( dist <= distance );
} 

//21-March
//Advanced tracing

//Traces a float, or int; whether a variable, an internal variable, array index, or other
//along with a given string in one function.
void TraceStr(int string, int value){
    TraceNL(); TraceS(string); Trace(value); TraceNL();
}

//This is where having char would be nice.

//As TraceStr, but for boolean values.
void TraceStrB(int string, bool val){
    TraceNL(); TraceS(string); TraceB(val); TraceNL();
}

//June 2016

//Returns if Link is facing an object. 
bool LinkFacing(ffc f){
	if ( Link->Dir == DIR_UP && Link->Y > f->Y ) return true;
	if ( Link->Dir == DIR_DOWN && Link->Y < f->Y ) return true;
	if ( Link->Dir == DIR_RIGHT && Link->X < f->X ) return true;
	if ( Link->Dir == DIR_LEFT && Link->X > f->X ) return true;
	return false;
}


bool LinkFacing(npc f){
	if ( Link->Dir == DIR_UP && Link->Y > f->Y ) return true;
	if ( Link->Dir == DIR_DOWN && Link->Y < f->Y ) return true;
	if ( Link->Dir == DIR_RIGHT && Link->X < f->X ) return true;
	if ( Link->Dir == DIR_LEFT && Link->X > f->X ) return true;
	return false;
}


bool LinkFacing(lweapon f){
	if ( Link->Dir == DIR_UP && Link->Y > f->Y ) return true;
	if ( Link->Dir == DIR_DOWN && Link->Y < f->Y ) return true;
	if ( Link->Dir == DIR_RIGHT && Link->X < f->X ) return true;
	if ( Link->Dir == DIR_LEFT && Link->X > f->X ) return true;
	return false;
}


bool LinkFacing(eweapon f){
	if ( Link->Dir == DIR_UP && Link->Y > f->Y ) return true;
	if ( Link->Dir == DIR_DOWN && Link->Y < f->Y ) return true;
	if ( Link->Dir == DIR_RIGHT && Link->X < f->X ) return true;
	if ( Link->Dir == DIR_LEFT && Link->X > f->X ) return true;
	return false;
}


bool LinkFacing(item f){
	if ( Link->Dir == DIR_UP && Link->Y > f->Y ) return true;
	if ( Link->Dir == DIR_DOWN && Link->Y < f->Y ) return true;
	if ( Link->Dir == DIR_RIGHT && Link->X < f->X ) return true;
	if ( Link->Dir == DIR_LEFT && Link->X > f->X ) return true;
	return false;
}

bool LinkFacing(int combo_pos){
	int posX = ComboX(combo_pos);
	int posY = ComboY(combo_pos);
	if ( Link->Dir == DIR_UP && Link->Y > posY ) return true;
	if ( Link->Dir == DIR_DOWN && Link->Y < posY ) return true;
	if ( Link->Dir == DIR_RIGHT && Link->X < posX ) return true;
	if ( Link->Dir == DIR_LEFT && Link->X > posX ) return true;
	return false;
}

//We need facing checks for poiner vs pointer

//NPC facing 'l'
bool Facing (npc n, ffc l){
	if ( n->Dir == DIR_UP && n->Y < l->Y ) return true;
	if ( n->Dir == DIR_DOWN && n->Y > l->Y ) return true;
	if ( n->Dir == DIR_RIGHT && n->X > l->X ) return true;
	if ( n->Dir == DIR_LEFT && n->X < l->X ) return true;
	return false;	
}
	
bool Facing (npc n, lweapon l){
	if ( n->Dir == DIR_UP && n->Y < l->Y ) return true;
	if ( n->Dir == DIR_DOWN && n->Y > l->Y ) return true;
	if ( n->Dir == DIR_RIGHT && n->X > l->X ) return true;
	if ( n->Dir == DIR_LEFT && n->X < l->X ) return true;
	return false;	
}
bool Facing (npc n, eweapon l){
	if ( n->Dir == DIR_UP && n->Y < l->Y ) return true;
	if ( n->Dir == DIR_DOWN && n->Y > l->Y ) return true;
	if ( n->Dir == DIR_RIGHT && n->X > l->X ) return true;
	if ( n->Dir == DIR_LEFT && n->X < l->X ) return true;
	return false;	
}
bool Facing (npc n, item l){
	if ( n->Dir == DIR_UP && n->Y < l->Y ) return true;
	if ( n->Dir == DIR_DOWN && n->Y > l->Y ) return true;
	if ( n->Dir == DIR_RIGHT && n->X > l->X ) return true;
	if ( n->Dir == DIR_LEFT && n->X < l->X ) return true;
	return false;	
}

//npc vs. npc
bool Facing (npc n, npc l){
	if ( n->Dir == DIR_UP && n->Y < l->Y ) return true;
	if ( n->Dir == DIR_DOWN && n->Y > l->Y ) return true;
	if ( n->Dir == DIR_RIGHT && n->X > l->X ) return true;
	if ( n->Dir == DIR_LEFT && n->X < l->X ) return true;
	return false;	
}
				//Facing Link
bool Facing (npc n){
	if ( n->Dir == DIR_UP && n->Y < Link->Y ) return true;
	if ( n->Dir == DIR_DOWN && n->Y > Link->Y ) return true;
	if ( n->Dir == DIR_RIGHT && n->X > Link->X ) return true;
	if ( n->Dir == DIR_LEFT && n->X < Link->X ) return true;
	return false;
}

bool Facing (npc n, int combo_pos){
	int posX = ComboX(combo_pos);
	int posY = ComboY(combo_pos);
	if ( n->Dir == DIR_UP && n->Y > posY ) return true;
	if ( n->Dir == DIR_DOWN && n->Y < posY ) return true;
	if ( n->Dir == DIR_RIGHT && n->X < posX ) return true;
	if ( n->Dir == DIR_LEFT && n->X > posX ) return true;
	return false;
}


//lweapon facing 'l'
bool Facing (lweapon n, ffc l){
	if ( n->Dir == DIR_UP && n->Y < l->Y ) return true;
	if ( n->Dir == DIR_DOWN && n->Y > l->Y ) return true;
	if ( n->Dir == DIR_RIGHT && n->X > l->X ) return true;
	if ( n->Dir == DIR_LEFT && n->X < l->X ) return true;
	return false;	
}
	
bool Facing (lweapon n, npc l){
	if ( n->Dir == DIR_UP && n->Y < l->Y ) return true;
	if ( n->Dir == DIR_DOWN && n->Y > l->Y ) return true;
	if ( n->Dir == DIR_RIGHT && n->X > l->X ) return true;
	if ( n->Dir == DIR_LEFT && n->X < l->X ) return true;
	return false;	
}
bool Facing (lweapon n, eweapon l){
	if ( n->Dir == DIR_UP && n->Y < l->Y ) return true;
	if ( n->Dir == DIR_DOWN && n->Y > l->Y ) return true;
	if ( n->Dir == DIR_RIGHT && n->X > l->X ) return true;
	if ( n->Dir == DIR_LEFT && n->X < l->X ) return true;
	return false;	
}
bool Facing (lweapon n, item l){
	if ( n->Dir == DIR_UP && n->Y < l->Y ) return true;
	if ( n->Dir == DIR_DOWN && n->Y > l->Y ) return true;
	if ( n->Dir == DIR_RIGHT && n->X > l->X ) return true;
	if ( n->Dir == DIR_LEFT && n->X < l->X ) return true;
	return false;	
}


//lweapon vs. lweapon
bool Facing (lweapon n, lweapon l){
	if ( n->Dir == DIR_UP && n->Y < l->Y ) return true;
	if ( n->Dir == DIR_DOWN && n->Y > l->Y ) return true;
	if ( n->Dir == DIR_RIGHT && n->X > l->X ) return true;
	if ( n->Dir == DIR_LEFT && n->X < l->X ) return true;
	return false;	
}
				//Facing Link
bool Facing (lweapon n){
	if ( n->Dir == DIR_UP && Link->Y < n->Y ) return true;
	if ( n->Dir == DIR_DOWN && Link->Y > n->Y ) return true;
	if ( n->Dir == DIR_RIGHT && Link->X > n->X ) return true;
	if ( n->Dir == DIR_LEFT && Link->X < n->X ) return true;
	return false;
}

bool Facing (lweapon n, int combo_pos){
	int posX = ComboX(combo_pos);
	int posY = ComboY(combo_pos);
	if ( n->Dir == DIR_UP && n->Y > posY ) return true;
	if ( n->Dir == DIR_DOWN && n->Y < posY ) return true;
	if ( n->Dir == DIR_RIGHT && n->X < posX ) return true;
	if ( n->Dir == DIR_LEFT && n->X > posX ) return true;
	return false;
}

//eweapon facing 'l'
bool Facing (eweapon n, ffc l){
	if ( n->Dir == DIR_UP && n->Y < l->Y ) return true;
	if ( n->Dir == DIR_DOWN && n->Y > l->Y ) return true;
	if ( n->Dir == DIR_RIGHT && n->X > l->X ) return true;
	if ( n->Dir == DIR_LEFT && n->X < l->X ) return true;
	return false;	
}
	
bool Facing (eweapon n, npc l){
	if ( n->Dir == DIR_UP && n->Y < l->Y ) return true;
	if ( n->Dir == DIR_DOWN && n->Y > l->Y ) return true;
	if ( n->Dir == DIR_RIGHT && n->X > l->X ) return true;
	if ( n->Dir == DIR_LEFT && n->X < l->X ) return true;
	return false;	
}
bool Facing (eweapon n, lweapon l){
	if ( n->Dir == DIR_UP && n->Y < l->Y ) return true;
	if ( n->Dir == DIR_DOWN && n->Y > l->Y ) return true;
	if ( n->Dir == DIR_RIGHT && n->X > l->X ) return true;
	if ( n->Dir == DIR_LEFT && n->X < l->X ) return true;
	return false;	
}
bool Facing (eweapon n, item l){
	if ( n->Dir == DIR_UP && n->Y < l->Y ) return true;
	if ( n->Dir == DIR_DOWN && n->Y > l->Y ) return true;
	if ( n->Dir == DIR_RIGHT && n->X > l->X ) return true;
	if ( n->Dir == DIR_LEFT && n->X < l->X ) return true;
	return false;	
}


//eweapon vs. eweapon
bool Facing (eweapon n, eweapon l){
	if ( n->Dir == DIR_UP && n->Y < l->Y ) return true;
	if ( n->Dir == DIR_DOWN && n->Y > l->Y ) return true;
	if ( n->Dir == DIR_RIGHT && n->X > l->X ) return true;
	if ( n->Dir == DIR_LEFT && n->X < l->X ) return true;
	return false;	
}
				//Facing Link
bool Facing (eweapon n){
	if ( n->Dir == DIR_UP && Link->Y < n->Y ) return true;
	if ( n->Dir == DIR_DOWN && Link->Y > n->Y ) return true;
	if ( n->Dir == DIR_RIGHT && Link->X > n->X ) return true;
	if ( n->Dir == DIR_LEFT && Link->X < n->X ) return true;
	return false;
}

bool Facing (eweapon n, int combo_pos){
	int posX = ComboX(combo_pos);
	int posY = ComboY(combo_pos);
	if ( n->Dir == DIR_UP && n->Y > posY ) return true;
	if ( n->Dir == DIR_DOWN && n->Y < posY ) return true;
	if ( n->Dir == DIR_RIGHT && n->X < posX ) return true;
	if ( n->Dir == DIR_LEFT && n->X > posX ) return true;
	return false;
}

//FFCs don;t have a direction, so it'll need to be arbitrary.

//const int FFC_DIR = 10; //f->Misc
//lweapon facing 'l'
bool Facing (ffc f, lweapon l, int ffc_dir){
	if ( ffc_dir == DIR_UP && f->Y < l->Y ) return true;
	if ( ffc_dir == DIR_DOWN && f->Y > l->Y ) return true;
	if ( ffc_dir == DIR_RIGHT && f->X > l->X ) return true;
	if ( ffc_dir == DIR_LEFT && f->X < l->X ) return true;
	return false;	
}

bool Facing (ffc f, npc l, int ffc_dir){
	if ( ffc_dir == DIR_UP && f->Y < l->Y ) return true;
	if ( ffc_dir == DIR_DOWN && f->Y > l->Y ) return true;
	if ( ffc_dir == DIR_RIGHT && f->X > l->X ) return true;
	if ( ffc_dir == DIR_LEFT && f->X < l->X ) return true;
	return false;	
}

bool Facing (ffc f, eweapon l, int ffc_dir){
	if ( ffc_dir == DIR_UP && f->Y < l->Y ) return true;
	if ( ffc_dir == DIR_DOWN && f->Y > l->Y ) return true;
	if ( ffc_dir == DIR_RIGHT && f->X > l->X ) return true;
	if ( ffc_dir == DIR_LEFT && f->X < l->X ) return true;
	return false;	
}

bool Facing (ffc f, item l, int ffc_dir){
	if ( ffc_dir == DIR_UP && f->Y < l->Y ) return true;
	if ( ffc_dir == DIR_DOWN && f->Y > l->Y ) return true;
	if ( ffc_dir == DIR_RIGHT && f->X > l->X ) return true;
	if ( ffc_dir == DIR_LEFT && f->X < l->X ) return true;
	return false;	
}

//two ffcs
bool Facing (ffc f, ffc l, int ffc_dir){
	if ( ffc_dir == DIR_UP && f->Y < l->Y ) return true;
	if ( ffc_dir == DIR_DOWN && f->Y > l->Y ) return true;
	if ( ffc_dir == DIR_RIGHT && f->X > l->X ) return true;
	if ( ffc_dir == DIR_LEFT && f->X < l->X ) return true;
	return false;	
}
				//Facig Link
bool Facing (ffc f, int ffc_dir){
	if ( ffc_dir == DIR_UP && Link->Y < f->Y ) return true;
	if ( ffc_dir == DIR_DOWN && Link->Y > f->Y ) return true;
	if ( ffc_dir == DIR_RIGHT && Link->X > f->X ) return true;
	if ( ffc_dir == DIR_LEFT && Link->X < f->X ) return true;
	return false;
}

//Combo
bool Facing (ffc f, int ffc_dir, int combo_pos){
	int posX = ComboX(combo_pos);
	int posY = ComboY(combo_pos);
	if ( ffc_dir == DIR_UP && f->Y > posY ) return true;
	if ( ffc_dir == DIR_DOWN && f->Y < posY ) return true;
	if ( ffc_dir == DIR_RIGHT && f->X < posX ) return true;
	if ( ffc_dir == DIR_LEFT && f->X > posX ) return true;
	return false;
}

//Do items have a dir? No, it'll also be arbitrary, then...

//item facing 'l'
bool Facing (item f, lweapon l, int ffc_dir){
	if ( ffc_dir == DIR_UP && f->Y < l->Y ) return true;
	if ( ffc_dir == DIR_DOWN && f->Y > l->Y ) return true;
	if ( ffc_dir == DIR_RIGHT && f->X > l->X ) return true;
	if ( ffc_dir == DIR_LEFT && f->X < l->X ) return true;
	return false;	
}

bool Facing (item f, npc l, int ffc_dir){
	if ( ffc_dir == DIR_UP && f->Y < l->Y ) return true;
	if ( ffc_dir == DIR_DOWN && f->Y > l->Y ) return true;
	if ( ffc_dir == DIR_RIGHT && f->X > l->X ) return true;
	if ( ffc_dir == DIR_LEFT && f->X < l->X ) return true;
	return false;	
}

bool Facing (item f, eweapon l, int ffc_dir){
	if ( ffc_dir == DIR_UP && f->Y < l->Y ) return true;
	if ( ffc_dir == DIR_DOWN && f->Y > l->Y ) return true;
	if ( ffc_dir == DIR_RIGHT && f->X > l->X ) return true;
	if ( ffc_dir == DIR_LEFT && f->X < l->X ) return true;
	return false;	
}

bool Facing (item f, ffc l, int ffc_dir){
	if ( ffc_dir == DIR_UP && f->Y < l->Y ) return true;
	if ( ffc_dir == DIR_DOWN && f->Y > l->Y ) return true;
	if ( ffc_dir == DIR_RIGHT && f->X > l->X ) return true;
	if ( ffc_dir == DIR_LEFT && f->X < l->X ) return true;
	return false;	
}

//two items
bool Facing (item f, item l, int ffc_dir){
	if ( ffc_dir == DIR_UP && f->Y < l->Y ) return true;
	if ( ffc_dir == DIR_DOWN && f->Y > l->Y ) return true;
	if ( ffc_dir == DIR_RIGHT && f->X > l->X ) return true;
	if ( ffc_dir == DIR_LEFT && f->X < l->X ) return true;
	return false;	
}
				//Facig Link
bool Facing (item f, int ffc_dir){
	if ( ffc_dir == DIR_UP && Link->Y < f->Y ) return true;
	if ( ffc_dir == DIR_DOWN && Link->Y > f->Y ) return true;
	if ( ffc_dir == DIR_RIGHT && Link->X > f->X ) return true;
	if ( ffc_dir == DIR_LEFT && Link->X < f->X ) return true;
	return false;
}

//Combo
bool Facing (item f, int ffc_dir, int cmb_pos){
	int posX = ComboX(cmb_pos);
	int posY = ComboY(cmb_pos);
	if ( ffc_dir == DIR_UP && f->Y > posY ) return true;
	if ( ffc_dir == DIR_DOWN && f->Y < posY ) return true;
	if ( ffc_dir == DIR_RIGHT && f->X < posX ) return true;
	if ( ffc_dir == DIR_LEFT && f->X > posX ) return true;
	return false;
}

void TraceA(bool arr,int size, bool verbose){TraceArrayB(arr,size,verbose);}
void TraceA(float arr, bool verbose){TraceArray(arr,verbose);}

int FlipRev(lweapon l){
	if ( l->Dir == DIR_DOWN || l->Dir == DIR_UP && !l->Flip ) return 2;
	if ( l->Dir == DIR_DOWN || l->Dir == DIR_UP && l->Flip ) return 0; 
	if ( l->Dir == DIR_LEFT || l->Dir == DIR_RIGHT && !l->Flip ) return 1;
	if ( l->Dir == DIR_LEFT || l->Dir == DIR_RIGHT && l->Flip ) return 0;
	return -1;
}

int FlipRev(eweapon l){
	if ( l->Dir == DIR_DOWN || l->Dir == DIR_UP && !l->Flip ) return 2;
	if ( l->Dir == DIR_DOWN || l->Dir == DIR_UP && l->Flip ) return 0; 
	if ( l->Dir == DIR_LEFT || l->Dir == DIR_RIGHT && !l->Flip ) return 1;
	if ( l->Dir == DIR_LEFT || l->Dir == DIR_RIGHT && l->Flip ) return 0;
	return -1;
}

bool Above(npc n){ return Link->Y < n->Y; }
bool Below(npc n){ return Link->Y > n->Y; }
bool LeftOf(npc n){ return Link->X < n->X; }
bool RightOf(npc n){ return Link->X > n->X; }

bool Above(ffc n){ return Link->Y < n->Y; }
bool Below(ffc n){ return Link->Y > n->Y; }
bool LeftOf(ffc n){ return Link->X < n->X; }
bool RightOf(ffc n){ return Link->X > n->X; }

bool Above(eweapon n){ return Link->Y < n->Y; }
bool Below(eweapon n){ return Link->Y > n->Y; }
bool LeftOf(eweapon n){ return Link->X < n->X; }
bool RightOf(eweapon n){ return Link->X > n->X; }

bool Above(lweapon n){ return Link->Y < n->Y; }
bool Below(lweapon n){ return Link->Y > n->Y; }
bool LeftOf(lweapon n){ return Link->X < n->X; }
bool RightOf(lweapon n){ return Link->X > n->X; }


bool DistXY(ffc a, lweapon b, int distance) {
	int distx; int disty;
	if ( a->X > b->X ) distx = a->X - b->X;
	else distx = b->X - a->X;
	
	if ( a->Y > b->Y ) disty = a->Y - b->Y;
	else disty = b->Y - a->Y;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(ffc a, eweapon b, int distance) {
	int distx; int disty;
	if ( a->X > b->X ) distx = a->X - b->X;
	else distx = b->X - a->X;
	
	if ( a->Y > b->Y ) disty = a->Y - b->Y;
	else disty = b->Y - a->Y;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(ffc a, npc b, int distance) {
	int distx; int disty;
	if ( a->X > b->X ) distx = a->X - b->X;
	else distx = b->X - a->X;
	
	if ( a->Y > b->Y ) disty = a->Y - b->Y;
	else disty = b->Y - a->Y;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(ffc a, item b, int distance) {
	int distx; int disty;
	if ( a->X > b->X ) distx = a->X - b->X;
	else distx = b->X - a->X;
	
	if ( a->Y > b->Y ) disty = a->Y - b->Y;
	else disty = b->Y - a->Y;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(ffc a, ffc b, int distance) {
	int distx; int disty;
	if ( a->X > b->X ) distx = a->X - b->X;
	else distx = b->X - a->X;
	
	if ( a->Y > b->Y ) disty = a->Y - b->Y;
	else disty = b->Y - a->Y;

	return ( distx <= distance && disty <= distance );
} 
//npc

bool DistXY(npc a, lweapon b, int distance) {
	int distx; int disty;
	if ( a->X > b->X ) distx = a->X - b->X;
	else distx = b->X - a->X;
	
	if ( a->Y > b->Y ) disty = a->Y - b->Y;
	else disty = b->Y - a->Y;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(npc a, eweapon b, int distance) {
	int distx; int disty;
	if ( a->X > b->X ) distx = a->X - b->X;
	else distx = b->X - a->X;
	
	if ( a->Y > b->Y ) disty = a->Y - b->Y;
	else disty = b->Y - a->Y;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(npc a, npc b, int distance) {
	int distx; int disty;
	if ( a->X > b->X ) distx = a->X - b->X;
	else distx = b->X - a->X;
	
	if ( a->Y > b->Y ) disty = a->Y - b->Y;
	else disty = b->Y - a->Y;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(npc a, item b, int distance) {
	int distx; int disty;
	if ( a->X > b->X ) distx = a->X - b->X;
	else distx = b->X - a->X;
	
	if ( a->Y > b->Y ) disty = a->Y - b->Y;
	else disty = b->Y - a->Y;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(npc a, ffc b, int distance) {
	int distx; int disty;
	if ( a->X > b->X ) distx = a->X - b->X;
	else distx = b->X - a->X;
	
	if ( a->Y > b->Y ) disty = a->Y - b->Y;
	else disty = b->Y - a->Y;

	return ( distx <= distance && disty <= distance );
} 

//lweapon

bool DistXY(lweapon a, lweapon b, int distance) {
	int distx; int disty;
	if ( a->X > b->X ) distx = a->X - b->X;
	else distx = b->X - a->X;
	
	if ( a->Y > b->Y ) disty = a->Y - b->Y;
	else disty = b->Y - a->Y;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(lweapon a, eweapon b, int distance) {
	int distx; int disty;
	if ( a->X > b->X ) distx = a->X - b->X;
	else distx = b->X - a->X;
	
	if ( a->Y > b->Y ) disty = a->Y - b->Y;
	else disty = b->Y - a->Y;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(lweapon a, npc b, int distance) {
	int distx; int disty;
	if ( a->X > b->X ) distx = a->X - b->X;
	else distx = b->X - a->X;
	
	if ( a->Y > b->Y ) disty = a->Y - b->Y;
	else disty = b->Y - a->Y;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(lweapon a, item b, int distance) {
	int distx; int disty;
	if ( a->X > b->X ) distx = a->X - b->X;
	else distx = b->X - a->X;
	
	if ( a->Y > b->Y ) disty = a->Y - b->Y;
	else disty = b->Y - a->Y;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(lweapon a, ffc b, int distance) {
	int distx; int disty;
	if ( a->X > b->X ) distx = a->X - b->X;
	else distx = b->X - a->X;
	
	if ( a->Y > b->Y ) disty = a->Y - b->Y;
	else disty = b->Y - a->Y;

	return ( distx <= distance && disty <= distance );
} 

//eweapon

bool DistXY(eweapon a, lweapon b, int distance) {
	int distx; int disty;
	if ( a->X > b->X ) distx = a->X - b->X;
	else distx = b->X - a->X;
	
	if ( a->Y > b->Y ) disty = a->Y - b->Y;
	else disty = b->Y - a->Y;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(eweapon a, eweapon b, int distance) {
	int distx; int disty;
	if ( a->X > b->X ) distx = a->X - b->X;
	else distx = b->X - a->X;
	
	if ( a->Y > b->Y ) disty = a->Y - b->Y;
	else disty = b->Y - a->Y;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(eweapon a, npc b, int distance) {
	int distx; int disty;
	if ( a->X > b->X ) distx = a->X - b->X;
	else distx = b->X - a->X;
	
	if ( a->Y > b->Y ) disty = a->Y - b->Y;
	else disty = b->Y - a->Y;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(eweapon a, item b, int distance) {
	int distx; int disty;
	if ( a->X > b->X ) distx = a->X - b->X;
	else distx = b->X - a->X;
	
	if ( a->Y > b->Y ) disty = a->Y - b->Y;
	else disty = b->Y - a->Y;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(eweapon a, ffc b, int distance) {
	int distx; int disty;
	if ( a->X > b->X ) distx = a->X - b->X;
	else distx = b->X - a->X;
	
	if ( a->Y > b->Y ) disty = a->Y - b->Y;
	else disty = b->Y - a->Y;

	return ( distx <= distance && disty <= distance );
} 

//item

bool DistXY(item a, lweapon b, int distance) {
	int distx; int disty;
	if ( a->X > b->X ) distx = a->X - b->X;
	else distx = b->X - a->X;
	
	if ( a->Y > b->Y ) disty = a->Y - b->Y;
	else disty = b->Y - a->Y;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(item a, eweapon b, int distance) {
	int distx; int disty;
	if ( a->X > b->X ) distx = a->X - b->X;
	else distx = b->X - a->X;
	
	if ( a->Y > b->Y ) disty = a->Y - b->Y;
	else disty = b->Y - a->Y;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(item a, npc b, int distance) {
	int distx; int disty;
	if ( a->X > b->X ) distx = a->X - b->X;
	else distx = b->X - a->X;
	
	if ( a->Y > b->Y ) disty = a->Y - b->Y;
	else disty = b->Y - a->Y;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(item a, item b, int distance) {
	int distx; int disty;
	if ( a->X > b->X ) distx = a->X - b->X;
	else distx = b->X - a->X;
	
	if ( a->Y > b->Y ) disty = a->Y - b->Y;
	else disty = b->Y - a->Y;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(item a, ffc b, int distance) {
	int distx; int disty;
	if ( a->X > b->X ) distx = a->X - b->X;
	else distx = b->X - a->X;
	
	if ( a->Y > b->Y ) disty = a->Y - b->Y;
	else disty = b->Y - a->Y;

	return ( distx <= distance && disty <= distance );
} 

//combo

bool DistXY(int a, lweapon b, int distance) {
	int distx; int disty; int aX = ComboX(a); int aY = ComboY(a);
	if ( aX > b->X ) distx = aX - b->X;
	else distx = b->X - aX;
	
	if ( aY > b->Y ) disty = aY - b->Y;
	else disty = b->Y - aY;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(int a, eweapon b, int distance) {
	int distx; int disty; int aX = ComboX(a); int aY = ComboY(a);
	if ( aX > b->X ) distx = aX - b->X;
	else distx = b->X - aX;
	
	if ( aY > b->Y ) disty = aY - b->Y;
	else disty = b->Y - aY;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(int a, npc b, int distance) {
	int distx; int disty; int aX = ComboX(a); int aY = ComboY(a);
	if ( aX > b->X ) distx = aX - b->X;
	else distx = b->X - aX;
	
	if ( aY > b->Y ) disty = aY - b->Y;
	else disty = b->Y - aY;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(int a, item b, int distance) {
	int distx; int disty; int aX = ComboX(a); int aY = ComboY(a);
	if ( aX > b->X ) distx = aX - b->X;
	else distx = b->X - aX;
	
	if ( aY > b->Y ) disty = aY - b->Y;
	else disty = b->Y - aY;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(int a, ffc b, int distance) {
	int distx; int disty; int aX = ComboX(a); int aY = ComboY(a);
	if ( aX > b->X ) distx = aX - b->X;
	else distx = b->X - aX;
	
	if ( aY > b->Y ) disty = aY - b->Y;
	else disty = b->Y - aY;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(int a, int b, int distance) {
	int distx; int disty; int aX = ComboX(a); int aY = ComboY(a); 
	int bX = ComboX(b); int bY = ComboY(b); 
	if ( aX > bX ) distx = aX - bX;
	else distx = bX - aX;
	
	if ( aY > bY ) disty = aY - bY;
	else disty = bY - aY;

	return ( distx <= distance && disty <= distance );
} 


//combo reversed

bool DistXY(lweapon b, int a, int distance) {
	int distx; int disty; int aX = ComboX(a); int aY = ComboY(a);
	if ( aX > b->X ) distx = aX - b->X;
	else distx = b->X - aX;
	
	if ( aY > b->Y ) disty = aY - b->Y;
	else disty = b->Y - aY;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(eweapon b, int a, int distance) {
	int distx; int disty; int aX = ComboX(a); int aY = ComboY(a);
	if ( aX > b->X ) distx = aX - b->X;
	else distx = b->X - aX;
	
	if ( aY > b->Y ) disty = aY - b->Y;
	else disty = b->Y - aY;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(npc b, int a, int distance) {
	int distx; int disty; int aX = ComboX(a); int aY = ComboY(a);
	if ( aX > b->X ) distx = aX - b->X;
	else distx = b->X - aX;
	
	if ( aY > b->Y ) disty = aY - b->Y;
	else disty = b->Y - aY;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(item b, int a, int distance) {
	int distx; int disty; int aX = ComboX(a); int aY = ComboY(a);
	if ( aX > b->X ) distx = aX - b->X;
	else distx = b->X - aX;
	
	if ( aY > b->Y ) disty = aY - b->Y;
	else disty = b->Y - aY;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(ffc b, int a, int distance) {
	int distx; int disty; int aX = ComboX(a); int aY = ComboY(a);
	if ( aX > b->X ) distx = aX - b->X;
	else distx = b->X - aX;
	
	if ( aY > b->Y ) disty = aY - b->Y;
	else disty = b->Y - aY;

	return ( distx <= distance && disty <= distance );
} 

//Link

bool DistXY(lweapon b, int distance) {
	int distx; int disty;
	if ( Link->X > b->X ) distx = Link->X - b->X;
	else distx = b->X - Link->X;
	
	if ( Link->Y > b->Y ) disty = Link->Y - b->Y;
	else disty = b->Y - Link->Y;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(eweapon b, int distance) {
	int distx; int disty;
	if ( Link->X > b->X ) distx = Link->X - b->X;
	else distx = b->X - Link->X;
	
	if ( Link->Y > b->Y ) disty = Link->Y - b->Y;
	else disty = b->Y - Link->Y;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(npc b, int distance) {
	int distx; int disty;
	if ( Link->X > b->X ) distx = Link->X - b->X;
	else distx = b->X - Link->X;
	
	if ( Link->Y > b->Y ) disty = Link->Y - b->Y;
	else disty = b->Y - Link->Y;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(item b, int distance) {
	int distx; int disty;
	if ( Link->X > b->X ) distx = Link->X - b->X;
	else distx = b->X - Link->X;
	
	if ( Link->Y > b->Y ) disty = Link->Y - b->Y;
	else disty = b->Y - Link->Y;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(ffc b, int distance) {
	int distx; int disty;
	if ( Link->X > b->X ) distx = Link->X - b->X;
	else distx = b->X - Link->X;
	
	if ( Link->Y > b->Y ) disty = Link->Y - b->Y;
	else disty = b->Y - Link->Y;

	return ( distx <= distance && disty <= distance );
} 

bool DistXY(int a, int distance) {
	int distx; int disty; int aX = ComboX(a); int aY = ComboY(a);
	if ( aX > Link->X ) distx = aX - Link->X;
	else distx = Link->X - aX;
	
	if ( aY > Link->Y ) disty = aY - Link->Y;
	else disty = Link->Y - aY;

	return ( distx <= distance && disty <= distance );
} 

//Reflect weapons / tennis / mirror / prism
lweapon ReflectWeapon(lweapon l, bool angular, int random_factor){
	l->Dir = DirRev(l->Dir);
	l->Flip = FlipRev(l);
	l->Angular = angular;
	if ( angular ) {
		if (l->Angle >= 180 ) l->Angle -= (180 - Rand(random_factor));
		else l->Angle += (180 + Rand(random_factor));
	}
}
lweapon ReflectWeapon(lweapon l, bool angular){
	l->Dir = DirRev(l->Dir);
	l->Flip = FlipRev(l);
	l->Angular = angular;
	if ( angular ) {
		if (l->Angle >= 180 ) l->Angle -= 180;
		else l->Angle += 180;
	}
}

lweapon ReflectWeapon(lweapon l){
	l->Dir = DirRev(l->Dir);
	l->Flip = FlipRev(l);
}
	
eweapon ReflectWeapon(eweapon l, bool angular, int random_factor){
	l->Dir = DirRev(l->Dir);
	l->Flip = FlipRev(l);
	l->Angular = angular;
	if ( angular ) {
		if (l->Angle >= 180 ) l->Angle -= (180 - Rand(random_factor));
		else l->Angle += (180 + Rand(random_factor));
	}
}

eweapon ReflectWeapon(eweapon l, bool angular){
	l->Dir = DirRev(l->Dir);
	l->Flip = FlipRev(l);
	l->Angular = angular;
	if ( angular ) {
		if (l->Angle >= 180 ) l->Angle -= 180;
		else l->Angle += 180;
	}
}

	
float ChangeIntegerValue(float n, int newval){
	newval = newval << 0;
	int high = (n << 0);
	int low = n - ( n << 0);
	return newval+low;
}

float ChangeDecimalValue(float n, float newval){
	newval = newval - ( newval << 0);
	int high = (n << 0);
	int low = n - ( n << 0);
	return newval+high;
}

float AddIntegerValue(float n, int newval){
	newval = newval << 0;
	int high = (n << 0) + newval;
	int low = n - ( n << 0);
	return high+low;
}

float AddDecimalValue(float n, float newval){
	newval = newval - ( newval << 0);
	int high = (n << 0);
	int low = ( n - ( n << 0)  ) +newval;
	return low+high;
}


//Returns true if Link is using item 'id'
bool _UsingItem(int id){
	return (GetEquipmentA() == id && (Link->InputA || Link->PressA )) || (GetEquipmentB() == id && (Link->InputB || Link->PressB));
}